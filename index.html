<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OCR Image Processor with Clickable Text Highlights and Crop Feature</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tesseract.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 15px;
        }
        p {
            margin-bottom: 15px;
        }
        .input-section {
            margin-bottom: 20px;
        }
        .input-section label {
            display: block;
            margin: 10px 0 5px 0;
        }
        #imageInput {
            margin-bottom: 10px;
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        #imageContainer {
            position: relative;
            display: inline-block;
            margin-top: 10px;
            padding: 0;
            max-width: 100%;
            touch-action: none; /* Prevent default touch actions */
        }
        #uploadedImage {
            max-width: 100%;
            border: 1px solid #ddd;
            display: block;
        }
        /* Updated overlayCanvas CSS: Removed width and height */
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: auto;
            /* Removed width and height to manage via JavaScript */
        }
        #statusMessage {
            font-size: 14px;
            color: #555;
            margin-top: 10px;
        }
        #fieldContainer {
            margin-top: 20px;
        }
        #fieldContainer label {
            font-weight: bold;
            margin: 10px 0 5px 0;
        }
        #fieldContainer input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }
        .buttons-container button {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            margin-right: 10px;
            margin-top: 10px;
            color: #fff;
        }
        #perform-ocr {
            background-color: #2cb67d;
        }
        #update-table {
            background-color: #3498db;
        }
        #save-csv {
            background-color: #f39c12;
        }
        #clear-image {
            background-color: #d00000;
        }
        #draw-button, #crop-button {
            background-color: #8e44ad;
            color: #fff;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 10px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        table, th, td {
            border: 1px solid #ccc;
        }
        th, td {
            padding: 8px;
            text-align: left;
            font-size: 14px;
        }
        th {
            background: #f2f2f2;
            font-weight: bold;
        }

        /* Mobile Responsive Adjustments */
        @media (max-width: 600px) {
            .buttons-container button {
                width: 100%;
                margin-bottom: 10px;
            }
            #draw-button, #crop-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>OCR Image Processor with Clickable Text Highlights and Crop Feature</h1>
    <p>Upload an image and perform OCR. Use the "Draw" button to select specific areas for OCR or the "Crop" button to crop the image. Recognized words within drawn rectangles will be highlighted in light blue on the image. Click on a highlighted block to assign the concatenated text to one of the input fields (Item Name Short, Item Name Long, UPC, Location, Downstack, Notes). You can edit fields manually as well. Once done, press "Update Table" to add a row to the table. Process multiple images by clearing the image and fields. Finally, press "Save CSV" to download all collected data.</p>

    <div class="input-section">
        <!-- Added Draw and Crop Buttons -->
        <button id="draw-button">Draw</button>
        <button id="crop-button">Crop</button>
        <label for="imageInput">Upload Image:</label>
        <input type="file" id="imageInput" accept="image/*">
        <div id="imageContainer" style="display:none;">
            <img id="uploadedImage" alt="Uploaded Image">
            <canvas id="overlayCanvas"></canvas>
        </div>
        <p id="statusMessage"></p>
        <button id="perform-ocr">Perform OCR</button>
        <button id="clear-image">Clear Image & Fields</button>
    </div>

    <div id="fieldContainer">
        <label for="field1">Item Name Short:</label>
        <input type="text" id="field1">
        <label for="field2">Item Name Long:</label>
        <input type="text" id="field2">
        <label for="field3">UPC:</label>
        <input type="text" id="field3">
        <label for="field4">Location:</label>
        <input type="text" id="field4">
        <label for="field5">Downstack:</label>
        <input type="text" id="field5">
        <label for="field6">Notes:</label>
        <input type="text" id="field6">
    </div>

    <div class="buttons-container">
        <button id="update-table">Update Table</button>
        <button id="save-csv">Save CSV</button>
    </div>

    <table id="dataTable">
        <thead>
            <tr>
                <th>Item Name Short</th>
                <th>Item Name Long</th>
                <th>UPC</th>
                <th>Location</th>
                <th>Downstack</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be appended here -->
        </tbody>
    </table>

    <script>
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const imageContainer = document.getElementById('imageContainer');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const performOcrButton = document.getElementById('perform-ocr');
        const clearImageButton = document.getElementById('clear-image');
        const statusMessage = document.getElementById('statusMessage');
        const dataTable = document.getElementById('dataTable').querySelector('tbody');
        const drawButton = document.getElementById('draw-button');
        const cropButton = document.getElementById('crop-button');

        const field1 = document.getElementById('field1');
        const field2 = document.getElementById('field2');
        const field3 = document.getElementById('field3');
        const field4 = document.getElementById('field4');
        const field5 = document.getElementById('field5');
        const field6 = document.getElementById('field6');

        const updateTableButton = document.getElementById('update-table');
        const saveCsvButton = document.getElementById('save-csv');

        let currentWords = []; // Store recognized words with their bounding boxes
        let imageDataURL = null; // For OCR
        let rectangles = []; // Store user-drawn rectangles
        let isDrawingMode = false;
        let isCroppingMode = false;
        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentRect = null;

        // Groups for highlighted blocks
        let wordGroups = []; // Each group has {text: '...', x, y, width, height}

        // Handle high-DPI displays
        function adjustCanvas() {
            const ctx = overlayCanvas.getContext('2d');
            const ratio = window.devicePixelRatio || 1;
            overlayCanvas.width = uploadedImage.clientWidth * ratio;
            overlayCanvas.height = uploadedImage.clientHeight * ratio;
            overlayCanvas.style.width = `${uploadedImage.clientWidth}px`;
            overlayCanvas.style.height = `${uploadedImage.clientHeight}px`;
            ctx.scale(ratio, ratio);
            redrawCanvas();
        }

        // Event Listener for Image Upload
        imageInput.addEventListener('change', () => {
            const file = imageInput.files[0];
            if (!file) {
                resetImageDisplay();
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedImage.src = e.target.result;
                uploadedImage.onload = () => {
                    imageContainer.style.display = 'inline-block';
                    
                    adjustCanvas();

                    clearCanvas();
                    statusMessage.textContent = 'Image loaded. You can crop or draw on the image.';
                    imageDataURL = e.target.result;
                    // Reset any previous drawings
                    rectangles = [];
                    wordGroups = [];
                };
            };
            reader.readAsDataURL(file);
        });

        // Event Listener for Draw Button
        drawButton.addEventListener('click', () => {
            if (!imageDataURL) {
                alert('Please upload an image first.');
                return;
            }
            if (isCroppingMode) {
                // If cropping mode is active, deactivate it
                isCroppingMode = false;
                cropButton.textContent = 'Crop';
            }
            isDrawingMode = !isDrawingMode;
            if (isDrawingMode) {
                drawButton.textContent = 'Cancel Draw';
                statusMessage.textContent = 'Draw mode activated. Click and drag on the image to draw rectangles for OCR.';
            } else {
                drawButton.textContent = 'Draw';
                statusMessage.textContent = 'Draw mode deactivated.';
                currentRect = null;
                redrawCanvas();
            }
        });

        // Event Listener for Crop Button
        cropButton.addEventListener('click', () => {
            if (!imageDataURL) {
                alert('Please upload an image first.');
                return;
            }
            if (isDrawingMode) {
                // If draw mode is active, deactivate it
                isDrawingMode = false;
                drawButton.textContent = 'Draw';
            }
            isCroppingMode = !isCroppingMode;
            if (isCroppingMode) {
                cropButton.textContent = 'Cancel Crop';
                statusMessage.textContent = 'Crop mode activated. Click and drag on the image to select the crop area.';
            } else {
                cropButton.textContent = 'Crop';
                statusMessage.textContent = 'Crop mode deactivated.';
                currentRect = null;
                redrawCanvas();
            }
        });

        // Mouse Events for Desktop Drawing/Cropping
        overlayCanvas.addEventListener('mousedown', (e) => {
            if (!isDrawingMode && !isCroppingMode) return;
            isDrawing = true;
            const rect = overlayCanvas.getBoundingClientRect();
            startX = (e.clientX - rect.left);
            startY = (e.clientY - rect.top);
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        });

        overlayCanvas.addEventListener('mousemove', (e) => {
            if ((!isDrawingMode && !isCroppingMode) || !isDrawing) return;
            const rect = overlayCanvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left);
            const mouseY = (e.clientY - rect.top);

            currentRect.width = mouseX - startX;
            currentRect.height = mouseY - startY;

            redrawCanvas();
            const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
            drawRectangle(currentRect, style.fill, style.stroke);
        });

        overlayCanvas.addEventListener('mouseup', (e) => {
            if ((!isDrawingMode && !isCroppingMode) || !isDrawing) return;
            isDrawing = false;
            if (currentRect.width !== 0 && currentRect.height !== 0) {
                // Normalize rectangle dimensions
                const normalizedRect = normalizeRect(currentRect);
                if (isDrawingMode) {
                    rectangles.push(normalizedRect);
                    statusMessage.textContent = `${rectangles.length} rectangle(s) drawn for OCR.`;
                } else if (isCroppingMode) {
                    performCrop(normalizedRect);
                    statusMessage.textContent = 'Image cropped successfully.';
                }
            }
            currentRect = null;
            redrawCanvas();
        });

        // Touch Events for Mobile Drawing/Cropping
        overlayCanvas.addEventListener('touchstart', (e) => {
            if (!isDrawingMode && !isCroppingMode) return;
            e.preventDefault(); // Prevent scrolling
            if (e.touches.length !== 1) return; // Only single touch
            isDrawing = true;
            const rect = overlayCanvas.getBoundingClientRect();
            startX = (e.touches[0].clientX - rect.left);
            startY = (e.touches[0].clientY - rect.top);
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        }, { passive: false });

        overlayCanvas.addEventListener('touchmove', (e) => {
            if ((!isDrawingMode && !isCroppingMode) || !isDrawing) return;
            e.preventDefault(); // Prevent scrolling
            if (e.touches.length !== 1) return; // Only single touch
            const rect = overlayCanvas.getBoundingClientRect();
            const touchX = (e.touches[0].clientX - rect.left);
            const touchY = (e.touches[0].clientY - rect.top);

            currentRect.width = touchX - startX;
            currentRect.height = touchY - startY;

            redrawCanvas();
            const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
            drawRectangle(currentRect, style.fill, style.stroke);
        }, { passive: false });

        overlayCanvas.addEventListener('touchend', (e) => {
            if ((!isDrawingMode && !isCroppingMode) || !isDrawing) return;
            isDrawing = false;
            if (currentRect.width !== 0 && currentRect.height !== 0) {
                // Normalize rectangle dimensions
                const normalizedRect = normalizeRect(currentRect);
                if (isDrawingMode) {
                    rectangles.push(normalizedRect);
                    statusMessage.textContent = `${rectangles.length} rectangle(s) drawn for OCR.`;
                } else if (isCroppingMode) {
                    performCrop(normalizedRect);
                    statusMessage.textContent = 'Image cropped successfully.';
                }
            }
            currentRect = null;
            redrawCanvas();
        });

        // Perform OCR Button
        performOcrButton.addEventListener('click', async () => {
            if (!imageDataURL) {
                alert('Please select an image first.');
                return;
            }
            if (rectangles.length === 0) {
                alert('Please draw at least one rectangle to select OCR areas.');
                return;
            }
            statusMessage.textContent = 'Performing OCR... please wait.';
            clearCanvas();
            wordGroups = [];
            const textData = await runOCR(imageDataURL);
            statusMessage.textContent = 'OCR complete. Click on highlighted blocks to assign fields.';
            processOCRData(textData);
            drawWordGroups();
        });

        // Handle Clicks on Highlighted Blocks
        overlayCanvas.addEventListener('click', (e) => {
            if (wordGroups.length === 0) return;
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left);
            const y = (e.clientY - rect.top);

            for (let group of wordGroups) {
                if (x >= group.x && x <= group.x + group.width && y >= group.y && y <= group.y + group.height) {
                    assignGroupToField(group.text);
                    break;
                }
            }
        });

        // Prevent Context Menu on Canvas (optional)
        overlayCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Clear Image Button
        clearImageButton.addEventListener('click', () => {
            resetImageDisplay();
            resetFields();
            statusMessage.textContent = 'Cleared image and fields. Table is preserved. You can upload a new image.';
        });

        // Update Table Button
        updateTableButton.addEventListener('click', () => {
            const row = document.createElement('tr');
            const cols = [field1.value.trim(), field2.value.trim(), field3.value.trim(), field4.value.trim(), field5.value.trim(), field6.value.trim()];
            if (cols.every(c => c === '')) {
                alert('All fields are empty. Nothing to add.');
                return;
            }
            cols.forEach(c => {
                const td = document.createElement('td');
                td.textContent = c;
                row.appendChild(td);
            });
            dataTable.appendChild(row);
            alert('Row added to the table.');
            resetFields();
        });

        // Save CSV Button
        saveCsvButton.addEventListener('click', () => {
            const rows = dataTable.querySelectorAll('tr');
            if (rows.length === 0) {
                alert('No data to save.');
                return;
            }
            const headers = ["Item Name Short", "Item Name Long", "UPC", "Location", "Downstack", "Notes"];
            const data = [headers];

            rows.forEach(r => {
                const cells = r.querySelectorAll('td');
                const rowData = Array.from(cells).map(cell => `"${cell.textContent.replace(/"/g, '""')}"`);
                data.push(rowData);
            });

            const csvContent = data.map(r => r.join(',')).join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ocr_data.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Function to Reset Image Display
        function resetImageDisplay() {
            uploadedImage.src = '';
            imageContainer.style.display = 'none';
            imageDataURL = null;
            clearCanvas();
            rectangles = [];
            wordGroups = [];
            isDrawingMode = false;
            isCroppingMode = false;
            drawButton.textContent = 'Draw';
            cropButton.textContent = 'Crop';
        }

        // Function to Reset Input Fields
        function resetFields() {
            field1.value = '';
            field2.value = '';
            field3.value = '';
            field4.value = '';
            field5.value = '';
            field6.value = '';
        }

        // Function to Clear Canvas
        function clearCanvas() {
            const ctx = overlayCanvas.getContext('2d');
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        }

        // Function to Redraw Canvas
        function redrawCanvas() {
            clearCanvas();
            // Draw existing rectangles
            rectangles.forEach(rect => {
                drawRectangle(rect, 'rgba(255, 0, 0, 0.3)', 'red');
            });
            // Draw word groups
            wordGroups.forEach(group => {
                drawRectangle(group, 'rgba(0, 150, 255, 0.25)', 'rgba(0, 150, 255, 1)');
            });
            // Draw current rectangle if any
            if (currentRect) {
                const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
                drawRectangle(currentRect, style.fill, style.stroke);
            }
        }

        // Function to Draw a Rectangle
        function drawRectangle(rect, fillStyle, strokeStyle) {
            const ctx = overlayCanvas.getContext('2d');
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 2;
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }

        // Function to Normalize Rectangle (handles negative width/height)
        function normalizeRect(rect) {
            let { x, y, width, height } = rect;
            if (width < 0) {
                x += width;
                width = Math.abs(width);
            }
            if (height < 0) {
                y += height;
                height = Math.abs(height);
            }
            return { x, y, width, height };
        }

        // Function to Run OCR using Tesseract.js
        async function runOCR(dataURL) {
            const worker = await Tesseract.createWorker({
                logger: m => console.log(m)
            });
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            const { data } = await worker.recognize(dataURL);
            await worker.terminate();
            return data;
        }

        // Function to Process OCR Data and Group Words within Rectangles
        function processOCRData(data) {
            if (!data.words) return;

            // For each rectangle, find words within it
            rectangles.forEach(rect => {
                const wordsInRect = data.words.filter(word => {
                    const wordX = word.bbox.x0 * (uploadedImage.clientWidth / uploadedImage.naturalWidth);
                    const wordY = word.bbox.y0 * (uploadedImage.clientHeight / uploadedImage.naturalHeight);
                    const wordW = (word.bbox.x1 - word.bbox.x0) * (uploadedImage.clientWidth / uploadedImage.naturalWidth);
                    const wordH = (word.bbox.y1 - word.bbox.y0) * (uploadedImage.clientHeight / uploadedImage.naturalHeight);
                    return (
                        wordX >= rect.x &&
                        wordY >= rect.y &&
                        (wordX + wordW) <= (rect.x + rect.width) &&
                        (wordY + wordH) <= (rect.y + rect.height)
                    );
                });

                if (wordsInRect.length > 0) {
                    // Concatenate words to form a single string
                    const sortedWords = wordsInRect.sort((a, b) => {
                        if (a.bbox.y0 === b.bbox.y0) {
                            return a.bbox.x0 - b.bbox.x0;
                        }
                        return a.bbox.y0 - b.bbox.y0;
                    });
                    const concatenatedText = sortedWords.map(w => w.text).join(' ');

                    // Calculate the bounding box that encompasses all words
                    const x0 = Math.min(...wordsInRect.map(w => w.bbox.x0));
                    const y0 = Math.min(...wordsInRect.map(w => w.bbox.y0));
                    const x1 = Math.max(...wordsInRect.map(w => w.bbox.x1));
                    const y1 = Math.max(...wordsInRect.map(w => w.bbox.y1));

                    const groupRect = {
                        x: x0 * (uploadedImage.clientWidth / uploadedImage.naturalWidth),
                        y: y0 * (uploadedImage.clientHeight / uploadedImage.naturalHeight),
                        width: (x1 - x0) * (uploadedImage.clientWidth / uploadedImage.naturalWidth),
                        height: (y1 - y0) * (uploadedImage.clientHeight / uploadedImage.naturalHeight),
                        text: concatenatedText
                    };

                    wordGroups.push(groupRect);
                }
            });
        }

        // Function to Draw Word Groups
        function drawWordGroups() {
            redrawCanvas();
        }

        // Function to Assign Group Text to a Field
        function assignGroupToField(text) {
            const choice = prompt(
                `Choose a field to assign this text:\n` +
                `1) Item Name Short\n` +
                `2) Item Name Long\n` +
                `3) UPC\n` +
                `4) Location\n` +
                `5) Downstack\n` +
                `6) Notes\n\n` +
                `Enter a number 1-6:`
            );
            if (!choice) return; // User canceled
            const num = parseInt(choice, 10);
            if (isNaN(num) || num < 1 || num > 6) {
                alert('Invalid choice.');
                return;
            }

            let targetField;
            switch (num) {
                case 1: targetField = field1; break;
                case 2: targetField = field2; break;
                case 3: targetField = field3; break;
                case 4: targetField = field4; break;
                case 5: targetField = field5; break;
                case 6: targetField = field6; break;
            }

            targetField.value = text;
        }

        // Prevent scrolling when touching the canvas in draw or crop mode
        document.body.addEventListener('touchstart', function(e) {
            if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchend', function(e) {
            if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchmove', function(e) {
            if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
                e.preventDefault();
            }
        }, { passive: false });

        // Function to Perform Cropping
        function performCrop(rect) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Calculate scaling factors
            const scaleX = uploadedImage.naturalWidth / uploadedImage.clientWidth;
            const scaleY = uploadedImage.naturalHeight / uploadedImage.clientHeight;

            // Define the crop area on the original image
            const cropX = rect.x * scaleX;
            const cropY = rect.y * scaleY;
            const cropWidth = rect.width * scaleX;
            const cropHeight = rect.height * scaleY;

            canvas.width = cropWidth;
            canvas.height = cropHeight;

            ctx.drawImage(uploadedImage, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
            const croppedDataURL = canvas.toDataURL();

            // Update the image source
            uploadedImage.src = croppedDataURL;
            imageDataURL = croppedDataURL;

            // Adjust canvas for the new image size
            uploadedImage.onload = () => {
                adjustCanvas();
                clearCanvas();
                // Reset any previous drawings
                rectangles = [];
                wordGroups = [];
            };
        }

        // Handle Window Resize to Adjust Canvas
        window.addEventListener('resize', () => {
            if (imageDataURL) {
                adjustCanvas();
            }
        });
    </script>
</body>
</html>
