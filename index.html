<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OCR Image Processor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tesseract.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    <style>
        /* General Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            text-align: center;
        }

        p {
            margin-bottom: 10px;
            text-align: center;
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
            font-size: 14px;
        }

        /* Centered Container */
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        /* Side Menu Styles */
        #sideMenu {
            height: 100%;
            width: 250px;
            position: fixed;
            top: 0;
            left: -250px;
            background-color: #1e1e1e;
            overflow-x: hidden;
            transition: 0.3s;
            padding-top: 60px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Button Base Styles */
        #sideMenu button {
            padding: 12px 20px;
            width: 80%;
            margin: 4px 0;
            color: #e0e0e0;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            position: relative;
            overflow: hidden;
            text-align: center;
        }

        /* Specific Button Colors */
        #draw-button {
            background-color: #005cb8; 
        }
        #draw-button:hover {
            background-color: #1C86EE;
            transform: translateX(5px);
        }

        #undo-draw-button {
            background-color: #c47f00; /* Orange */
        }
        #undo-draw-button:hover {
            background-color: #FF8C00;
            transform: translateX(5px);
        }

        #crop-button {
            background-color: #009d00; /* LimeGreen */
        }
        #crop-button:hover {
            background-color: #2E8B57;
            transform: translateX(5px);
        }

        #confirm-crop-button {
            background-color: #00e200; /* LimeGreen */
        }
        #confirm-crop-button:hover {
            background-color: #2E8B57;
            transform: translateX(5px);
        }

        #perform-ocr-button {
            background-color: #9c009c; /* Purple */
        }
        #perform-ocr-button:hover {
            background-color: #6A0DAD;
            transform: translateX(5px);
        }

        #clear-image-button {
            background-color: #e43d00; /* OrangeRed */
        }
        #clear-image-button:hover {
            background-color: #E03E00;
            transform: translateX(5px);
        }

        #update-table-button {
            background-color: #00958d; /* LightSeaGreen */
        }
        #update-table-button:hover {
            background-color: #1E9C9C;
            transform: translateX(5px);
        }

        #save-csv-button {
            background-color: #a2a200; /* Gold */
            color: #000; /* Black text for better contrast */
        }
        #save-csv-button:hover {
            background-color: #FFC107;
            transform: translateX(5px);
        }

        #postprocessing-button {
            background-color: #009da0; /* DarkTurquoise */
        }
        #postprocessing-button:hover {
            background-color: #00B3A1;
            transform: translateX(5px);
        }

        /* Hamburger Menu Button Styles */
        #hamburgerBtn {
            width: 50px;
            height: 50px;
            background-color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
            position: fixed; /* Fixed position */
            top: 20px; /* 20px from top */
            left: 20px; /* 20px from left */
            z-index: 1100; /* Above side menu */
        }

        #hamburgerBtn:hover {
            background-color: #444;
        }

        /* Hamburger Icon */
        .bar {
            display: block;
            width: 30px;
            height: 4px;
            background-color: #e0e0e0;
            margin: 4px 0;
            transition: 0.4s;
            border-radius: 2px;
        }

        /* Side Menu Active State */
        #sideMenu.active {
            left: 0;
        }

        /* Input Section */
        .input-section {
            margin-bottom: 20px;
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        .input-section label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: bold;
            font-size: 16px;
        }

        #imageInput {
            margin-bottom: 15px;
            width: 80%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background-color: #2c2c2c;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
        }

        #imageInput::file-selector-button {
            background-color: #555;
            color: #e0e0e0;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 14px;
        }

        #imageInput::file-selector-button:hover {
            background-color: #666;
        }

        /* Image Container */
        #imageContainer {
            position: relative;
            display: none;
            max-width: 100%;
            margin: 0 auto;
        }

        #uploadedImage {
            max-width: 100%;
            border: 2px solid #333;
            border-radius: 8px;
            display: block;
        }

        /* Canvas Styles */
        #postprocessingCanvas, #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 8px;
            width: 100%;
            height: 100%;
        }

        #postprocessingCanvas {
            z-index: 5;
            pointer-events: none;
        }

        #overlayCanvas {
            z-index: 10;
            pointer-events: auto;
        }

        /* Status Message */
        #statusMessage {
            font-size: 14px;
            color: #b0b0b0;
            margin-top: 10px;
            text-align: center;
        }

        /* Field Container */
        #fieldContainer {
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            padding: 0 10px;
        }

        #fieldContainer label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: bold;
            font-size: 16px;
        }

        #fieldContainer input[type="text"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border: none;
            border-radius: 4px;
            background-color: #2c2c2c;
            color: #e0e0e0;
            font-size: 14px;
        }

        /* Buttons in Side Menu */
        .buttons-container {
            display: none; /* Hidden since moved to side menu */
        }

        /* Postprocessing Controls */
        .postprocessing-controls {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 90%;
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .postprocessing-controls label {
            width: 100%;
            margin: 8px 0 4px 0;
            text-align: left;
            color: #e0e0e0;
            font-size: 14px;
        }

        .postprocessing-controls input[type="range"],
        .postprocessing-controls input[type="checkbox"] {
            width: 100%;
            margin-bottom: 10px;
        }

        /* Data Table */
        #dataTable {
            width: 90%;
            max-width: 800px;
            margin: 20px auto;
            border-collapse: collapse;
            background-color: #1e1e1e;
            border-radius: 8px;
            overflow: hidden;
        }

        #dataTable th, #dataTable td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #333;
            font-size: 14px;
        }

        #dataTable th {
            background-color: #333;
            color: #e0e0e0;
        }

        #dataTable tr:hover {
            background-color: #2a2a2a;
        }

        /* Modern Button Styles */
        .side-menu-button {
            position: relative;
        }

        .side-menu-button::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 0%;
            height: 2px;
            background-color: #e0e0e0;
            transition: width 0.3s;
        }

        .side-menu-button:hover::after {
            width: 100%;
        }

        /* Responsive Adjustments for Mobile */
        @media (max-width: 600px) {
            #sideMenu {
                width: 200px;
            }

            #hamburgerBtn {
                width: 40px;
                height: 40px;
                top: 15px;
                left: 15px;
            }

            #sideMenu button {
                font-size: 14px;
                padding: 10px 15px;
            }

            h1 {
                font-size: 22px;
            }

            p {
                font-size: 13px;
            }

            #fieldContainer label, .postprocessing-controls label {
                font-size: 14px;
            }

            #fieldContainer input[type="text"], .postprocessing-controls input[type="range"], .postprocessing-controls input[type="checkbox"] {
                font-size: 13px;
            }

            #dataTable th, #dataTable td {
                font-size: 13px;
                padding: 10px 12px;
            }
        }

       /* Specific Styles for the Info Button */
        #info-button {
            background-color: #8c8c8c; /* Desired background color */
            color: #fff;            /* Desired text color */
            /* Optional: Add other styles as needed */
            /* Example: */
            /* border: 2px solid #fff; */
        }

        /* Hover Effect for the Info Button */
        #info-button:hover {
            background-color: #666; /* Background color on hover */
            /* Optional: */
            /* color: #000; */     /* Text color on hover */
        }

        /* Active/Focus Effect for Accessibility */
        #info-button:active,
        #info-button:focus {
            background-color: #777; /* Background color when active or focused */
            outline: none;           /* Remove default outline */
            /* Optional: */
            /* border-color: #fff; */
        }

        /* Info Modal Styles */
        #infoModal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1500; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.5); /* Black w/ opacity */
        }

        /* Modal Content Box */
        #infoModalContent {
            background-color: #1e1e1e;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
            border-radius: 8px;
            color: #e0e0e0;
            position: relative;
        }

        /* Close Button */
        #infoModalClose {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            top: 10px;
            right: 20px;
            cursor: pointer;
        }

        #infoModalClose:hover,
        #infoModalClose:focus {
            color: #fff;
            text-decoration: none;
        }

    </style>
</head>
<body>
    <!-- Hamburger Menu Button -->
    <button id="hamburgerBtn" aria-label="Toggle Side Menu">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>

    <!-- Side Menu -->
    <div id="sideMenu">
        <button id="draw-button" class="side-menu-button">Draw</button>
        <button id="undo-draw-button" class="side-menu-button" style="display:none;">Undo Draw</button>
        <button id="crop-button" class="side-menu-button">Crop</button>
        <button id="confirm-crop-button" class="side-menu-button" style="display:none;">Confirm Crop</button>
        <button id="perform-ocr-button" class="side-menu-button">Perform OCR</button>
        <button id="clear-image-button" class="side-menu-button">Clear Image & Fields</button>
        <button id="update-table-button" class="side-menu-button">Update Table</button>
        <button id="save-csv-button" class="side-menu-button">Save CSV</button>

        <!-- Postprocessing Submenu -->
        <button id="postprocessing-button" class="side-menu-button">Postprocessing</button>
        <div class="postprocessing-controls" id="postprocessing-controls">
            <label for="grayscale">Grayscale:</label>
            <input type="checkbox" id="grayscale">

            <label for="highlight">Highlight:</label>
            <input type="range" id="highlight" min="0" max="100" value="0">

            <label for="clarity">Clarity:</label>
            <input type="range" id="clarity" min="0" max="100" value="50">

            <label for="brightness">Brightness:</label>
            <input type="range" id="brightness" min="-100" max="100" value="0">

            <label for="sharpening">Sharpening:</label>
            <input type="range" id="sharpening" min="0" max="100" value="0">
        </div>
        <!-- Info Button Added at the Bottom of Side Menu -->
        <button id="info-button" class="side-menu-button">Info</button>
    </div>

    <!-- Info Modal Structure -->
    <div id="infoModal">
        <div id="infoModalContent">
            <span id="infoModalClose">&times;</span>
            <h2>Information</h2>
            <ul>
               <li> Upload an image and perform OCR.</li> 
               <li> Use the side menu to select specific areas for OCR or to crop the image. </li>
               <li> After drawing a crop rectangle, click "Confirm Crop" to apply the crop. </li>
               <li> Recognized words within drawn rectangles will be highlighted in light blue on the image. </li>
                 <li> Click on a highlighted block to assign the concatenated text to one of the input fields. </li>
               <li> Once done, press "Update Table" to add a row to the table. </li>
               <li> Process multiple images by clearing the image and fields. </li>
               <li> Finally, press "Save CSV" to download all collected data. </li>
            </ul>
        </div>
    </div>

    <div class="container">
        <h1>OCR Image Processor</h1>
        <br>
        <br>
        <!--Main Input Section -->
        <div class="input-section">
            <label for="imageInput">Upload Image:</label>
            <input type="file" id="imageInput" accept="image/*">
            <div id="imageContainer">
                <img id="uploadedImage" alt="Uploaded Image">
                <!-- Postprocessing Canvas -->
                <canvas id="postprocessingCanvas"></canvas>
                <canvas id="overlayCanvas"></canvas>
            </div>
            <p id="statusMessage"></p>
        </div>

        <!-- Input Fields -->
        <div id="fieldContainer">
            <label for="field1">Item Name Short:</label>
            <input type="text" id="field1">
            <label for="field2">Item Name Long:</label>
            <input type="text" id="field2">
            <label for="field3">UPC:</label>
            <input type="text" id="field3">
            <label for="field4">Location:</label>
            <input type="text" id="field4">
            <label for="field5">Downstack:</label>
            <input type="text" id="field5">
            <label for="field6">Notes:</label>
            <input type="text" id="field6">
        </div>
    </div>

    <!-- Data Table -->
    <table id="dataTable">
        <thead>
            <tr>
                <th>Item Name Short</th>
                <th>Item Name Long</th>
                <th>UPC</th>
                <th>Location</th>
                <th>Downstack</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be appended here -->
        </tbody>
    </table>

    

    <script>
    // DOM Elements
    const imageInput = document.getElementById('imageInput');
    const uploadedImage = document.getElementById('uploadedImage');
    const imageContainer = document.getElementById('imageContainer');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const postprocessingCanvas = document.getElementById('postprocessingCanvas');
    const statusMessage = document.getElementById('statusMessage');
    const dataTable = document.getElementById('dataTable').querySelector('tbody');

    // Side Menu Buttons
    const drawButton = document.getElementById('draw-button');
    const undoDrawButton = document.getElementById('undo-draw-button');
    const cropButton = document.getElementById('crop-button');
    const confirmCropButton = document.getElementById('confirm-crop-button');
    const performOcrButton = document.getElementById('perform-ocr-button');
    const clearImageButton = document.getElementById('clear-image-button');
    const updateTableButton = document.getElementById('update-table-button');
    const saveCsvButton = document.getElementById('save-csv-button');

    // Postprocessing Controls
    const postprocessingButton = document.getElementById('postprocessing-button');
    const postprocessingControls = document.getElementById('postprocessing-controls');
    const grayscaleCheckbox = document.getElementById('grayscale');
    const highlightSlider = document.getElementById('highlight');
    const claritySlider = document.getElementById('clarity');
    const brightnessSlider = document.getElementById('brightness');
    const sharpeningSlider = document.getElementById('sharpening');

    // Input Fields
    const field1 = document.getElementById('field1');
    const field2 = document.getElementById('field2');
    const field3 = document.getElementById('field3');
    const field4 = document.getElementById('field4');
    const field5 = document.getElementById('field5');
    const field6 = document.getElementById('field6');

    // Hamburger Menu Button
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const sideMenu = document.getElementById('sideMenu');

    // DOM Elements for Info Modal
    const infoButton = document.getElementById('info-button');
    const infoModal = document.getElementById('infoModal');
    const infoModalClose = document.getElementById('infoModalClose');

    // State Variables
    let userRectangles = []; // Array to store user-drawn rectangles
    let rectangleTexts = {}; // Object to map rectangles to their OCR text
    let imageDataURL = null;
    let cropRect = null;
    let isDrawingMode = false;
    let isCroppingMode = false;
    let isDrawing = false;
    let isResizing = false;
    let isMoving = false; // New variable for moving
    let activeHandle = null;
    let startX = 0;
    let startY = 0;
    let currentRect = null;
    let moveOffset = { x: 0, y: 0 }; // Offset for moving
    let HANDLE_SIZE = 10;
    const HANDLE_HIT_RADIUS = 15; // Increased hit radius for better click/press margins
    // **Modified HANDLE_TYPES to only include 'sw' and 'ne'**
    const HANDLE_TYPES = ['sw', 'ne'];
    let resizeTarget = null;
    let handlesVisible = true;
    let initialRect = null; // New variable to store the initial rectangle during resize

    // Side Menu Toggle Function
    function toggleSideMenu() {
        sideMenu.classList.toggle('active');
    }

    // Event Listener for Hamburger Button
    hamburgerBtn.addEventListener('click', toggleSideMenu);

    // Close Side Menu on Escape Key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && sideMenu.classList.contains('active')) {
            sideMenu.classList.remove('active');
        }
    });

    // Close Side Menu When Clicking Outside
    window.addEventListener('click', (e) => {
        if (!sideMenu.contains(e.target) && e.target !== hamburgerBtn) {
            if (sideMenu.classList.contains('active')) {
                sideMenu.classList.remove('active');
            }
        }
    });

    // Event Listener to Open Info Modal
    infoButton.addEventListener('click', () => {
        infoModal.style.display = 'block';
    });

    // Event Listener to Close Info Modal when Close Button is Clicked
    infoModalClose.addEventListener('click', () => {
        infoModal.style.display = 'none';
    });

    // Event Listener to Close Info Modal when Clicking Outside the Modal Content
    window.addEventListener('click', (event) => {
        if (event.target == infoModal) {
            infoModal.style.display = 'none';
        }
    });

    // Event Listener for Postprocessing Button to Toggle Controls
    postprocessingButton.addEventListener('click', () => {
        postprocessingControls.style.display = postprocessingControls.style.display === 'flex' ? 'none' : 'flex';
    });

    // Adjust Canvas for High-DPI Displays and Responsive Sizing
    function adjustCanvas() {
        const ratio = window.devicePixelRatio || 1;

        // Adjust postprocessingCanvas
        postprocessingCanvas.width = uploadedImage.clientWidth * ratio;
        postprocessingCanvas.height = uploadedImage.clientHeight * ratio;
        postprocessingCanvas.style.width = `${uploadedImage.clientWidth}px`;
        postprocessingCanvas.style.height = `${uploadedImage.clientHeight}px`;
        const ppCtx = postprocessingCanvas.getContext('2d');
        ppCtx.scale(ratio, ratio);

        // Adjust overlayCanvas
        overlayCanvas.width = uploadedImage.clientWidth * ratio;
        overlayCanvas.height = uploadedImage.clientHeight * ratio;
        overlayCanvas.style.width = `${uploadedImage.clientWidth}px`;
        overlayCanvas.style.height = `${uploadedImage.clientHeight}px`;
        const ovCtx = overlayCanvas.getContext('2d');
        ovCtx.scale(ratio, ratio);

        // After adjusting, redraw postprocessing
        applyPostprocessing();
    }

    // Function to Update HANDLE_SIZE Based on Screen Width
    function updateHandleSize() {
        if (window.innerWidth <= 600) {
            HANDLE_SIZE = 10; // Keep HANDLE_SIZE the same for visual size
        } else {
            HANDLE_SIZE = 10; // Keep HANDLE_SIZE consistent
        }
        redrawCanvas();
    }

    // Call updateHandleSize on Initial Load and on Window Resize
    window.addEventListener('load', () => {
        updateHandleSize();
        if (uploadedImage.complete && uploadedImage.naturalWidth !== 0) {
            applyPostprocessing();
        }
    });
    window.addEventListener('resize', () => {
        adjustCanvas();
        updateHandleSize();
    });

    // Event Listener for Image Upload
    imageInput.addEventListener('change', () => {
        const file = imageInput.files[0];
        if (!file) {
            resetImageDisplay();
            return;
        }
        const reader = new FileReader();
        reader.onload = function(e) {
            uploadedImage.src = e.target.result;
            uploadedImage.onload = () => {
                imageContainer.style.display = 'block';
                
                adjustCanvas();

                clearCanvas();
                statusMessage.textContent = 'Image loaded. You can crop or draw on the image.';
                imageDataURL = e.target.result;
                userRectangles = [];
                rectangleTexts = {};
                cropRect = null;
                handlesVisible = true;
                confirmCropButton.style.display = 'none';
                undoDrawButton.style.display = 'none';
                redrawCanvas();

                applyPostprocessing();
            };
        };
        reader.readAsDataURL(file);
    });

    // Event Listener for Draw Button
    drawButton.addEventListener('click', () => {
        if (!imageDataURL) {
            alert('Please upload an image first.');
            return;
        }
        if (isCroppingMode) {
            isCroppingMode = false;
            cropButton.textContent = 'Crop';
            confirmCropButton.style.display = 'none';
        }
        isDrawingMode = !isDrawingMode;
        if (isDrawingMode) {
            drawButton.textContent = 'Cancel Draw';
            statusMessage.textContent = 'Draw mode activated. Tap and drag on the image to draw rectangles for OCR.';
            cropRect = null;
            confirmCropButton.style.display = 'none';
            handlesVisible = true;
            undoDrawButton.style.display = userRectangles.length > 0 ? 'block' : 'none';
            redrawCanvas();
        } else {
            drawButton.textContent = 'Draw';
            statusMessage.textContent = 'Draw mode deactivated.';
            currentRect = null;
            redrawCanvas();
        }
    });

    // Event Listener for Crop Button
    cropButton.addEventListener('click', () => {
        if (!imageDataURL) {
            alert('Please upload an image first.');
            return;
        }
        if (isDrawingMode) {
            isDrawingMode = false;
            drawButton.textContent = 'Draw';
        }
        isCroppingMode = !isCroppingMode;
        if (isCroppingMode) {
            cropButton.textContent = 'Cancel Crop';
            statusMessage.textContent = 'Crop mode activated. Tap and drag on the image to select the crop area.';
            cropRect = null;
            confirmCropButton.style.display = 'none';
            handlesVisible = true;
            redrawCanvas();
        } else {
            cropButton.textContent = 'Crop';
            statusMessage.textContent = 'Crop mode deactivated.';
            currentRect = null;
            confirmCropButton.style.display = 'none';
            redrawCanvas();
        }
    });

    // Event Listener for Confirm Crop Button
    confirmCropButton.addEventListener('click', () => {
        if (!cropRect) {
            alert('Please draw a crop rectangle first.');
            return;
        }
        performCrop(cropRect);
        isCroppingMode = false;
        cropButton.textContent = 'Crop';
        confirmCropButton.style.display = 'none';
        statusMessage.textContent = 'Image cropped successfully.';
        handlesVisible = false;
        redrawCanvas();
    });

    // Event Listener for Undo Draw Button
    undoDrawButton.addEventListener('click', () => {
        if (userRectangles.length === 0) {
            alert('No rectangles to undo.');
            return;
        }
        userRectangles.pop();
        redrawCanvas();
        statusMessage.textContent = 'Last drawn rectangle has been removed.';
        undoDrawButton.style.display = userRectangles.length > 0 ? 'block' : 'none';
    });

    // Mouse Events for Desktop Drawing/Cropping and Resizing
    overlayCanvas.addEventListener('mousedown', (e) => {
        const rect = overlayCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);

        const handleInfo = getHandleAt(x, y);
        if (handleInfo) {
            if (handleInfo.type === 'sw') {
                // Resizing
                isResizing = true;
                activeHandle = handleInfo.type;
                resizeTarget = handleInfo.rect === 'crop' ? 'crop' : handleInfo.index;
                // Store the initial rectangle state for proper resizing
                if (resizeTarget === 'crop') {
                    initialRect = { ...cropRect };
                } else {
                    initialRect = { ...userRectangles[resizeTarget] };
                }
            } else if (handleInfo.type === 'ne') {
                // Moving
                isMoving = true;
                resizeTarget = handleInfo.rect === 'crop' ? 'crop' : handleInfo.index;
                // Calculate offset
                if (resizeTarget === 'crop') {
                    moveOffset.x = x - cropRect.x;
                    moveOffset.y = y - cropRect.y;
                } else {
                    const rectToMove = userRectangles[resizeTarget];
                    moveOffset.x = x - rectToMove.x;
                    moveOffset.y = y - rectToMove.y;
                }
            }
            return;
        }

        if (isDrawingMode || (isCroppingMode && !cropRect)) {
            isDrawing = true;
            startX = x;
            startY = y;
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        }
    });

    overlayCanvas.addEventListener('mousemove', (e) => {
        const rect = overlayCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);

        if (isResizing) {
            resizeRectangle(x, y);
            redrawCanvas();
            return;
        }

        if (isMoving) {
            moveRectangle(x, y);
            redrawCanvas();
            return;
        }

        if (isDrawing && currentRect) {
            currentRect.width = x - startX;
            currentRect.height = y - startY;
            redrawCanvas();
            const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
            drawRectangle(currentRect, style.fill, style.stroke);
        }
    });

    overlayCanvas.addEventListener('mouseup', (e) => {
        if (isResizing) {
            isResizing = false;
            activeHandle = null;
            resizeTarget = null;
            initialRect = null; // Clear initial rectangle
            statusMessage.textContent = 'Rectangle resized.';
            return;
        }

        if (isMoving) {
            isMoving = false;
            resizeTarget = null;
            statusMessage.textContent = 'Rectangle moved.';
            return;
        }

        if (isDrawing && currentRect) {
            isDrawing = false;
            const normalizedRect = normalizeRect(currentRect);
            if (isDrawingMode) {
                userRectangles.push(normalizedRect);
                statusMessage.textContent = `${userRectangles.length} OCR rectangle(s) drawn.`;
                undoDrawButton.style.display = userRectangles.length > 0 ? 'block' : 'none';
            } else if (isCroppingMode) {
                if (cropRect) {
                    cropRect = normalizedRect;
                    statusMessage.textContent = 'Crop rectangle updated. You can resize or confirm the crop.';
                } else {
                    cropRect = normalizedRect;
                    statusMessage.textContent = 'Crop rectangle drawn. You can resize it using the handles or confirm the crop.';
                }
                confirmCropButton.style.display = 'block';
            }
            currentRect = null;
            redrawCanvas();
        }
    });

    // Touch Events for Mobile Drawing/Cropping and Resizing
    overlayCanvas.addEventListener('touchstart', (e) => {
        if (!(isDrawingMode || isCroppingMode)) return;
        e.preventDefault();
        if (e.touches.length !== 1) return;
        const rect = overlayCanvas.getBoundingClientRect();
        const x = (e.touches[0].clientX - rect.left);
        const y = (e.touches[0].clientY - rect.top);

        const handleInfo = getHandleAt(x, y);
        if (handleInfo) {
            if (handleInfo.type === 'sw') {
                // Resizing
                isResizing = true;
                activeHandle = handleInfo.type;
                resizeTarget = handleInfo.rect === 'crop' ? 'crop' : handleInfo.index;
                // Store the initial rectangle state for proper resizing
                if (resizeTarget === 'crop') {
                    initialRect = { ...cropRect };
                } else {
                    initialRect = { ...userRectangles[resizeTarget] };
                }
            } else if (handleInfo.type === 'ne') {
                // Moving
                isMoving = true;
                resizeTarget = handleInfo.rect === 'crop' ? 'crop' : handleInfo.index;
                // Calculate offset
                if (resizeTarget === 'crop') {
                    moveOffset.x = x - cropRect.x;
                    moveOffset.y = y - cropRect.y;
                } else {
                    const rectToMove = userRectangles[resizeTarget];
                    moveOffset.x = x - rectToMove.x;
                    moveOffset.y = y - rectToMove.y;
                }
            }
            return;
        }

        if (isDrawingMode || (isCroppingMode && !cropRect)) {
            isDrawing = true;
            startX = x;
            startY = y;
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        }
    }, { passive: false });

    overlayCanvas.addEventListener('touchmove', (e) => {
        if (!(isDrawingMode || isCroppingMode)) return;
        e.preventDefault();
        if (e.touches.length !== 1) return;
        const rect = overlayCanvas.getBoundingClientRect();
        const x = (e.touches[0].clientX - rect.left);
        const y = (e.touches[0].clientY - rect.top);

        if (isResizing) {
            resizeRectangle(x, y);
            redrawCanvas();
            return;
        }

        if (isMoving) {
            moveRectangle(x, y);
            redrawCanvas();
            return;
        }

        if (isDrawing && currentRect) {
            currentRect.width = x - startX;
            currentRect.height = y - startY;
            redrawCanvas();
            const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
            drawRectangle(currentRect, style.fill, style.stroke);
        }
    }, { passive: false });

    overlayCanvas.addEventListener('touchend', (e) => {
        if (isResizing) {
            isResizing = false;
            activeHandle = null;
            resizeTarget = null;
            initialRect = null; // Clear initial rectangle
            statusMessage.textContent = 'Rectangle resized.';
            return;
        }

        if (isMoving) {
            isMoving = false;
            resizeTarget = null;
            statusMessage.textContent = 'Rectangle moved.';
            return;
        }

        if (isDrawing && currentRect) {
            isDrawing = false;
            const normalizedRect = normalizeRect(currentRect);
            if (isDrawingMode) {
                userRectangles.push(normalizedRect);
                statusMessage.textContent = `${userRectangles.length} OCR rectangle(s) drawn.`;
                undoDrawButton.style.display = userRectangles.length > 0 ? 'block' : 'none';
            } else if (isCroppingMode) {
                if (cropRect) {
                    cropRect = normalizedRect;
                    statusMessage.textContent = 'Crop rectangle updated. You can resize or confirm the crop.';
                } else {
                    cropRect = normalizedRect;
                    statusMessage.textContent = 'Crop rectangle drawn. You can resize it using the handles or confirm the crop.';
                }
                confirmCropButton.style.display = 'block';
            }
            currentRect = null;
            redrawCanvas();
        }
    });

    // **New Function: Move Rectangle**
    function moveRectangle(x, y) {
        if (resizeTarget === 'crop') {
            if (!cropRect) return;
            cropRect.x = x - moveOffset.x;
            cropRect.y = y - moveOffset.y;
            cropRect = normalizeRect(cropRect);
        } else if (typeof resizeTarget === 'number') {
            const rect = userRectangles[resizeTarget];
            if (!rect) return;
            rect.x = x - moveOffset.x;
            rect.y = y - moveOffset.y;
            userRectangles[resizeTarget] = normalizeRect(rect);
        }
    }

    // Perform OCR Button
    performOcrButton.addEventListener('click', async () => {
        if (!imageDataURL) {
            alert('Please select an image first.');
            return;
        }
        if (userRectangles.length === 0) {
            alert('Please draw at least one rectangle to select OCR areas.');
            return;
        }

        if (isDrawingMode) {
            drawButton.click();
            statusMessage.textContent = 'Drawing mode exited. Performing OCR... please wait.';
        } else {
            statusMessage.textContent = 'Performing OCR... please wait.';
        }

        clearCanvas();
        statusMessage.textContent = 'Performing OCR on selected areas...';
        rectangleTexts = {}; // Reset previous texts

        for (let i = 0; i < userRectangles.length; i++) {
            const rect = userRectangles[i];
            const text = await performOCROnRectangle(rect);
            rectangleTexts[i] = text; // Map text to rectangle index
        }

        // **Added Line: Hide resize handles after OCR**
        handlesVisible = false;

        statusMessage.textContent = 'OCR complete. Click on highlighted areas to assign fields.';
        redrawCanvas(); // Redraw rectangles in blue
    });

    // Function to Perform OCR on a Specific Rectangle
    async function performOCROnRectangle(rect) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Calculate scaling factors
        const scaleX = uploadedImage.naturalWidth / uploadedImage.clientWidth;
        const scaleY = uploadedImage.naturalHeight / uploadedImage.clientHeight;

        // Define the crop area on the original image
        const cropX = rect.x * scaleX;
        const cropY = rect.y * scaleY;
        const cropWidth = rect.width * scaleX;
        const cropHeight = rect.height * scaleY;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(uploadedImage, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
        const croppedDataURL = canvas.toDataURL();

        // Perform OCR using Tesseract.js on the cropped image
        const worker = await Tesseract.createWorker({
            logger: m => console.log(m)
        });
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        const { data } = await worker.recognize(croppedDataURL);
        await worker.terminate();

        return data.text.trim();
    }

    // Handle Clicks on Highlighted Areas (Blue Rectangles)
    overlayCanvas.addEventListener('click', (e) => {
        if (userRectangles.length === 0) return;
        const rect = overlayCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);

        // Iterate through all user rectangles to find if click is inside any
        for (let i = 0; i < userRectangles.length; i++) {
            const r = userRectangles[i];
            if (x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height) {
                const text = rectangleTexts[i] || '';
                if (text === '') {
                    alert('No text extracted for this area.');
                    return;
                }
                assignTextToField(text);
                break;
            }
        }
    });

    // Prevent Context Menu on Canvas
    overlayCanvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });

    // Clear Image Button
    clearImageButton.addEventListener('click', () => {
        resetImageDisplay();
        resetFields();
        statusMessage.textContent = 'Cleared image and fields. Table is preserved. You can upload a new image.';
    });

    // Update Table Button
    updateTableButton.addEventListener('click', () => {
        const row = document.createElement('tr');
        const cols = [field1.value.trim(), field2.value.trim(), field3.value.trim(), field4.value.trim(), field5.value.trim(), field6.value.trim()];
        if (cols.every(c => c === '')) {
            alert('All fields are empty. Nothing to add.');
            return;
        }
        cols.forEach(c => {
            const td = document.createElement('td');
            td.textContent = c;
            row.appendChild(td);
        });
        dataTable.appendChild(row);
        alert('Row added to the table.');
        resetFields();
    });

    // Save CSV Button
    saveCsvButton.addEventListener('click', () => {
        const rows = dataTable.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('No data to save.');
            return;
        }
        const headers = ["Item Name Short", "Item Name Long", "UPC", "Location", "Downstack", "Notes"];
        const data = [headers];

        rows.forEach(r => {
            const cells = r.querySelectorAll('td');
            const rowData = Array.from(cells).map(cell => `"${cell.textContent.replace(/"/g, '""')}"`);
            data.push(rowData);
        });

        const csvContent = data.map(r => r.join(',')).join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ocr_data.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });

    // Function to Reset Image Display
    function resetImageDisplay() {
        uploadedImage.src = '';
        imageContainer.style.display = 'none';
        imageDataURL = null;
        clearCanvas();
        userRectangles = [];
        rectangleTexts = {};
        cropRect = null;
        isDrawingMode = false;
        isCroppingMode = false;
        drawButton.textContent = 'Draw';
        cropButton.textContent = 'Crop';
        confirmCropButton.style.display = 'none';
        handlesVisible = true;
        undoDrawButton.style.display = 'none';

        const ppCtx = postprocessingCanvas.getContext('2d');
        ppCtx.clearRect(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);
    }

    // Function to Reset Input Fields
    function resetFields() {
        field1.value = '';
        field2.value = '';
        field3.value = '';
        field4.value = '';
        field5.value = '';
        field6.value = '';
    }

    // Function to Clear Canvas
    function clearCanvas() {
        const ctx = overlayCanvas.getContext('2d');
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    }

    // Function to Redraw Canvas
    function redrawCanvas() {
        clearCanvas();
        // Draw existing user rectangles
        userRectangles.forEach((rect, index) => {
            const fillStyle = rectangleTexts[index] ? 'rgba(0, 150, 255, 0.3)' : 'rgba(255, 0, 0, 0.3)';
            const strokeStyle = rectangleTexts[index] ? 'blue' : 'red';
            drawRectangle(rect, fillStyle, strokeStyle);
            if (handlesVisible) {
                drawHandles(rect, index);
            }
        });
        // Draw crop rectangle if any
        if (cropRect) {
            drawRectangle(cropRect, 'rgba(0, 150, 255, 0.25)', 'rgba(0, 150, 255, 1)');
            if (handlesVisible) {
                drawHandles(cropRect, 'crop');
            }
        }
        // Draw current rectangle if any
        if (currentRect) {
            const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
            drawRectangle(currentRect, style.fill, style.stroke);
        }
    }

    // Function to Draw a Rectangle
    function drawRectangle(rect, fillStyle, strokeStyle) {
        const ctx = overlayCanvas.getContext('2d');
        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 2;
        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
    }

    // Function to Get Handle Positions Relative to the Rectangle
    function getHandlePositions(rect) {
        return {
            sw: { x: rect.x, y: rect.y + rect.height }, // Bottom-Left
            ne: { x: rect.x + rect.width, y: rect.y }   // Top-Right
        };
    }

    // **Updated Function: Draw Handles as Circles with Icons**
    function drawHandles(rect, identifier) {
        const ctx = overlayCanvas.getContext('2d');
        const handles = getHandlePositions(rect);
        ctx.fillStyle = '#e0e0e0'; // Grey color for handles
        ctx.strokeStyle = '#000';   // Black border for handles

        // Determine handle type based on identifier
        const isCrop = identifier === 'crop';
        const isResize = identifier === 'sw';
        const isMove = identifier === 'ne';

        // Draw 'sw' handle (resize)
        if (HANDLE_TYPES.includes('sw') && !isCrop) {
            const handle = handles['sw'];
            ctx.beginPath();
            ctx.arc(handle.x, handle.y, HANDLE_SIZE / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            // Draw resize icon: backslash with arrows
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(handle.x - HANDLE_SIZE / 4, handle.y - HANDLE_SIZE / 4);
            ctx.lineTo(handle.x + HANDLE_SIZE / 4, handle.y + HANDLE_SIZE / 4);
            ctx.moveTo(handle.x - HANDLE_SIZE / 4, handle.y);
            ctx.lineTo(handle.x - HANDLE_SIZE / 4, handle.y - HANDLE_SIZE / 8);
            ctx.moveTo(handle.x, handle.y + HANDLE_SIZE / 4);
            ctx.lineTo(handle.x - HANDLE_SIZE / 8, handle.y + HANDLE_SIZE / 4);
            ctx.moveTo(handle.x + HANDLE_SIZE / 4, handle.y + HANDLE_SIZE / 4);
            ctx.lineTo(handle.x + HANDLE_SIZE / 4, handle.y + HANDLE_SIZE / 8);
            ctx.stroke();
        }

        // Draw 'ne' handle (move)
        if (HANDLE_TYPES.includes('ne') && !isCrop) {
            const handle = handles['ne'];
            ctx.beginPath();
            ctx.arc(handle.x, handle.y, HANDLE_SIZE / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            // Draw move icon: plus with arrows
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Plus sign
            ctx.moveTo(handle.x, handle.y - HANDLE_SIZE / 4);
            ctx.lineTo(handle.x, handle.y + HANDLE_SIZE / 4);
            ctx.moveTo(handle.x - HANDLE_SIZE / 4, handle.y);
            ctx.lineTo(handle.x + HANDLE_SIZE / 4, handle.y);
            // Arrows
            // North arrow
            ctx.moveTo(handle.x, handle.y - HANDLE_SIZE / 4);
            ctx.lineTo(handle.x, handle.y - HANDLE_SIZE / 3);
            ctx.moveTo(handle.x - HANDLE_SIZE / 8, handle.y - HANDLE_SIZE / 3 + HANDLE_SIZE / 16);
            ctx.lineTo(handle.x, handle.y - HANDLE_SIZE / 3);
            ctx.lineTo(handle.x + HANDLE_SIZE / 8, handle.y - HANDLE_SIZE / 3 + HANDLE_SIZE / 16);
            // South arrow
            ctx.moveTo(handle.x, handle.y + HANDLE_SIZE / 4);
            ctx.lineTo(handle.x, handle.y + HANDLE_SIZE / 3);
            ctx.moveTo(handle.x - HANDLE_SIZE / 8, handle.y + HANDLE_SIZE / 3 - HANDLE_SIZE / 16);
            ctx.lineTo(handle.x, handle.y + HANDLE_SIZE / 3);
            ctx.lineTo(handle.x + HANDLE_SIZE / 8, handle.y + HANDLE_SIZE / 3 - HANDLE_SIZE / 16);
            // East arrow
            ctx.moveTo(handle.x + HANDLE_SIZE / 4, handle.y);
            ctx.lineTo(handle.x + HANDLE_SIZE / 3, handle.y);
            ctx.moveTo(handle.x + HANDLE_SIZE / 3 - HANDLE_SIZE / 16, handle.y - HANDLE_SIZE / 8);
            ctx.lineTo(handle.x + HANDLE_SIZE / 3, handle.y);
            ctx.lineTo(handle.x + HANDLE_SIZE / 3 - HANDLE_SIZE / 16, handle.y + HANDLE_SIZE / 8);
            // West arrow
            ctx.moveTo(handle.x - HANDLE_SIZE / 4, handle.y);
            ctx.lineTo(handle.x - HANDLE_SIZE / 3, handle.y);
            ctx.moveTo(handle.x - HANDLE_SIZE / 3 + HANDLE_SIZE / 16, handle.y - HANDLE_SIZE / 8);
            ctx.lineTo(handle.x - HANDLE_SIZE / 3, handle.y);
            ctx.lineTo(handle.x - HANDLE_SIZE / 3 + HANDLE_SIZE / 16, handle.y + HANDLE_SIZE / 8);
            ctx.stroke();
        }

        // If identifier is 'crop', draw handles accordingly (if needed)
        if (identifier === 'crop') {
            // Draw handles for crop rectangle if needed
            // Depending on the desired behavior, similar to 'sw' and 'ne'
            // For this example, let's assume crop handles are similar to user rectangle handles
            const handleSw = handles['sw'];
            const handleNe = handles['ne'];

            // Resize handle (sw) for crop
            ctx.beginPath();
            ctx.arc(handleSw.x, handleSw.y, HANDLE_SIZE / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            // Draw resize icon: backslash with arrows
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(handleSw.x - HANDLE_SIZE / 4, handleSw.y - HANDLE_SIZE / 4);
            ctx.lineTo(handleSw.x + HANDLE_SIZE / 4, handleSw.y + HANDLE_SIZE / 4);
            ctx.moveTo(handleSw.x - HANDLE_SIZE / 4, handleSw.y);
            ctx.lineTo(handleSw.x - HANDLE_SIZE / 4, handleSw.y - HANDLE_SIZE / 8);
            ctx.moveTo(handleSw.x, handleSw.y + HANDLE_SIZE / 4);
            ctx.lineTo(handleSw.x - HANDLE_SIZE / 8, handleSw.y + HANDLE_SIZE / 4);
            ctx.moveTo(handleSw.x + HANDLE_SIZE / 4, handleSw.y + HANDLE_SIZE / 4);
            ctx.lineTo(handleSw.x + HANDLE_SIZE / 4, handleSw.y + HANDLE_SIZE / 8);
            ctx.stroke();

            // Move handle (ne) for crop
            ctx.beginPath();
            ctx.arc(handleNe.x, handleNe.y, HANDLE_SIZE / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            // Draw move icon: plus with arrows
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Plus sign
            ctx.moveTo(handleNe.x, handleNe.y - HANDLE_SIZE / 4);
            ctx.lineTo(handleNe.x, handleNe.y + HANDLE_SIZE / 4);
            ctx.moveTo(handleNe.x - HANDLE_SIZE / 4, handleNe.y);
            ctx.lineTo(handleNe.x + HANDLE_SIZE / 4, handleNe.y);
            // Arrows
            // North arrow
            ctx.moveTo(handleNe.x, handleNe.y - HANDLE_SIZE / 4);
            ctx.lineTo(handleNe.x, handleNe.y - HANDLE_SIZE / 3);
            ctx.moveTo(handleNe.x - HANDLE_SIZE / 8, handleNe.y - HANDLE_SIZE / 3 + HANDLE_SIZE / 16);
            ctx.lineTo(handleNe.x, handleNe.y - HANDLE_SIZE / 3);
            ctx.lineTo(handleNe.x + HANDLE_SIZE / 8, handleNe.y - HANDLE_SIZE / 3 + HANDLE_SIZE / 16);
            // South arrow
            ctx.moveTo(handleNe.x, handleNe.y + HANDLE_SIZE / 4);
            ctx.lineTo(handleNe.x, handleNe.y + HANDLE_SIZE / 3);
            ctx.moveTo(handleNe.x - HANDLE_SIZE / 8, handleNe.y + HANDLE_SIZE / 3 - HANDLE_SIZE / 16);
            ctx.lineTo(handleNe.x, handleNe.y + HANDLE_SIZE / 3);
            ctx.lineTo(handleNe.x + HANDLE_SIZE / 8, handleNe.y + HANDLE_SIZE / 3 - HANDLE_SIZE / 16);
            // East arrow
            ctx.moveTo(handleNe.x + HANDLE_SIZE / 4, handleNe.y);
            ctx.lineTo(handleNe.x + HANDLE_SIZE / 3, handleNe.y);
            ctx.moveTo(handleNe.x + HANDLE_SIZE / 3 - HANDLE_SIZE / 16, handleNe.y - HANDLE_SIZE / 8);
            ctx.lineTo(handleNe.x + HANDLE_SIZE / 3, handleNe.y);
            ctx.lineTo(handleNe.x + HANDLE_SIZE / 3 - HANDLE_SIZE / 16, handleNe.y + HANDLE_SIZE / 8);
            // West arrow
            ctx.moveTo(handleNe.x - HANDLE_SIZE / 4, handleNe.y);
            ctx.lineTo(handleNe.x - HANDLE_SIZE / 3, handleNe.y);
            ctx.moveTo(handleNe.x - HANDLE_SIZE / 3 + HANDLE_SIZE / 16, handleNe.y - HANDLE_SIZE / 8);
            ctx.lineTo(handleNe.x - HANDLE_SIZE / 3, handleNe.y);
            ctx.lineTo(handleNe.x - HANDLE_SIZE / 3 + HANDLE_SIZE / 16, handleNe.y + HANDLE_SIZE / 8);
            ctx.stroke();
        }
    }

    // Check if Point is Inside Any Handle of Any Rectangle
    function getHandleAt(x, y) {
        // Check cropRect first
        if (cropRect) {
            const handle = getHandlePositions(cropRect);
            for (let key of HANDLE_TYPES) {
                const pos = handle[key];
                const distance = Math.hypot(x - pos.x, y - pos.y);
                if (distance <= HANDLE_HIT_RADIUS) {
                    return { type: key, rect: 'crop' };
                }
            }
        }

        // Check userRectangles
        for (let i = 0; i < userRectangles.length; i++) {
            const rect = userRectangles[i];
            const handles = getHandlePositions(rect);
            for (let key of HANDLE_TYPES) {
                const pos = handles[key];
                const distance = Math.hypot(x - pos.x, y - pos.y);
                if (distance <= HANDLE_HIT_RADIUS) {
                    return { type: key, rect: 'user', index: i };
                }
            }
        }

        return null;
    }

    // Function to Normalize Rectangle
    function normalizeRect(rect) {
        let { x, y, width, height } = rect;
        if (width < 0) {
            x += width;
            width = Math.abs(width);
        }
        if (height < 0) {
            y += height;
            height = Math.abs(height);
        }
        // Ensure rectangle stays within image boundaries
        x = Math.max(0, x);
        y = Math.max(0, y);
        width = Math.min(width, uploadedImage.clientWidth - x);
        height = Math.min(height, uploadedImage.clientHeight - y);
        return { x, y, width, height };
    }

    // Function to Perform Cropping
    function performCrop(rect) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Calculate scaling factors
        const scaleX = uploadedImage.naturalWidth / uploadedImage.clientWidth;
        const scaleY = uploadedImage.naturalHeight / uploadedImage.clientHeight;

        // Define the crop area on the original image
        const cropX = rect.x * scaleX;
        const cropY = rect.y * scaleY;
        const cropWidth = rect.width * scaleX;
        const cropHeight = rect.height * scaleY;

        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(uploadedImage, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
        const croppedDataURL = canvas.toDataURL();

        // Update the image source
        uploadedImage.src = croppedDataURL;
        imageDataURL = croppedDataURL;

        // Adjust canvas for the new image size
        uploadedImage.onload = () => {
            adjustCanvas();
            clearCanvas();
            userRectangles = [];
            rectangleTexts = {};
            cropRect = null;
            statusMessage.textContent = 'Image cropped successfully. You can now draw OCR rectangles.';
            handlesVisible = true;
            undoDrawButton.style.display = 'none';
            redrawCanvas();

            applyPostprocessing();
        };
    }

    // Function to Resize Rectangle
    function resizeRectangle(x, y) {
        // **Added Condition: Prevent resizing if OCR has been performed**
        if (!handlesVisible) return;

        if (resizeTarget === 'crop') {
            if (!cropRect || !activeHandle || !initialRect) return;
            switch (activeHandle) {
                case 'sw':
                    // Calculate new x and y based on mouse movement
                    const newX = x;
                    const newY = y;
                    const newWidth = initialRect.width + (initialRect.x - newX);
                    const newHeight = initialRect.height + (initialRect.y - newY);
                    if (newWidth > 20 && newHeight > 20) { // Minimum size constraint
                        cropRect.x = newX;
                        cropRect.y = newY;
                        cropRect.width = newWidth;
                        cropRect.height = newHeight;
                    }
                    break;
            }

            cropRect = normalizeRect(cropRect);
        } else if (typeof resizeTarget === 'number') {
            const rect = userRectangles[resizeTarget];
            if (!rect || !activeHandle || !initialRect) return;

            switch (activeHandle) {
                case 'sw':
                    // Calculate new x and y based on mouse movement
                    const newXr = x;
                    const newYr = y;
                    const newWidthr = initialRect.width + (initialRect.x - newXr);
                    const newHeightr = initialRect.height + (initialRect.y - newYr);
                    if (newWidthr > 20 && newHeightr > 20) { // Minimum size constraint
                        rect.x = newXr;
                        rect.y = newYr;
                        rect.width = newWidthr;
                        rect.height = newHeightr;
                    }
                    break;
            }

            userRectangles[resizeTarget] = normalizeRect(rect);
        }
    }

    // Prevent Scrolling When Touching the Canvas in Draw or Crop Mode
    document.body.addEventListener('touchstart', function(e) {
        if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.body.addEventListener('touchend', function(e) {
        if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
            e.preventDefault();
        }
    }, { passive: false });

    document.body.addEventListener('touchmove', function(e) {
        if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
            e.preventDefault();
        }
    }, { passive: false });

    /* -------------------- Postprocessing Functions -------------------- */

    // Function to Apply Postprocessing Effects
    function applyPostprocessing() {
        if (!uploadedImage.src) return;

        const ppCtx = postprocessingCanvas.getContext('2d');

        // Clear Postprocessing Canvas
        ppCtx.clearRect(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);

        // Draw the uploaded image onto Postprocessing Canvas
        ppCtx.drawImage(uploadedImage, 0, 0, uploadedImage.clientWidth, uploadedImage.clientHeight);

        // Get ImageData
        let imageData = ppCtx.getImageData(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);
        let data = imageData.data;

        // Apply Grayscale
        if (grayscaleCheckbox.checked) {
            for (let i = 0; i < data.length; i += 4) {
                const avg = 0.3 * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = avg;
            }
        }

        // Apply Brightness
        const brightnessValue = parseInt(brightnessSlider.value, 10);
        if (brightnessValue !== 0) {
            const factor = brightnessValue;
            for (let i = 0; i < data.length; i += 4) {
                data[i] += factor;
                data[i + 1] += factor;
                data[i + 2] += factor;
            }
        }

        // Apply Clarity (Contrast Adjustment)
        const clarityValue = parseInt(claritySlider.value, 10);
        if (clarityValue !== 50) {
            const contrast = clarityValue / 50;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = ((data[i] - 128) * contrast) + 128;
                data[i + 1] = ((data[i + 1] - 128) * contrast) + 128;
                data[i + 2] = ((data[i + 2] - 128) * contrast) + 128;
            }
        }

        // Apply Highlight (Additional Brightness)
        const highlightValue = parseInt(highlightSlider.value, 10);
        if (highlightValue !== 0) {
            const factor = highlightValue * 0.5;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] > 50 || data[i + 1] > 50 || data[i + 2] > 50) {
                    data[i] += factor;
                    data[i + 1] += factor;
                    data[i + 2] += factor;
                }
            }
        }

        // Put modified data back
        ppCtx.putImageData(imageData, 0, 0);

        // Apply Sharpening
        const sharpeningValue = parseInt(sharpeningSlider.value, 10);
        if (sharpeningValue > 0) {
            applySharpeningFilter(ppCtx, sharpeningValue / 100);
        }

        // Update imageDataURL to use the postprocessed image
        imageDataURL = postprocessingCanvas.toDataURL();

        // Redraw overlayCanvas
        redrawCanvas();
    }

    // Function to Apply Sharpening Filter
    function applySharpeningFilter(ctx, intensity) {
        const imageData = ctx.getImageData(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;

        // Simple sharpening kernel
        const kernel = [
            0, -1, 0,
            -1, 5, -1,
            0, -1, 0
        ];

        const side = Math.round(Math.sqrt(kernel.length));
        const halfSide = Math.floor(side / 2);

        const src = data;
        const sw = width;
        const sh = height;
        const w = sw;
        const h = sh;
        const output = new Uint8ClampedArray(src.length);

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                let r = 0, g = 0, b = 0;
                for (let ky = 0; ky < side; ky++) {
                    for (let kx = 0; kx < side; kx++) {
                        const pos = (y + ky - halfSide) * sw + (x + kx - halfSide);
                        if (pos >= 0 && pos < sw * sh) {
                            const offset = pos * 4;
                            const weight = kernel[ky * side + kx];
                            r += src[offset] * weight;
                            g += src[offset + 1] * weight;
                            b += src[offset + 2] * weight;
                        }
                    }
                }
                const dstOffset = (y * w + x) * 4;
                output[dstOffset] = Math.min(Math.max(r * intensity, 0), 255);
                output[dstOffset + 1] = Math.min(Math.max(g * intensity, 0), 255);
                output[dstOffset + 2] = Math.min(Math.max(b * intensity, 0), 255);
                output[dstOffset + 3] = src[dstOffset + 3];
            }
        }

        // Put the sharpened data back
        for (let i = 0; i < data.length; i++) {
            data[i] = output[i];
        }
        ctx.putImageData(imageData, 0, 0);
    }

    // Event Listeners for Postprocessing Controls
    grayscaleCheckbox.addEventListener('change', applyPostprocessing);
    highlightSlider.addEventListener('input', applyPostprocessing);
    claritySlider.addEventListener('input', applyPostprocessing);
    brightnessSlider.addEventListener('input', applyPostprocessing);
    sharpeningSlider.addEventListener('input', applyPostprocessing);

    /* -------------------- End of Postprocessing Functions -------------------- */

    // Function to Assign Text to Fields
    function assignTextToField(text) {
        const choice = prompt(
            `Choose a field to assign this text:\n` +
            `1) Item Name Short\n` +
            `2) Item Name Long\n` +
            `3) UPC\n` +
            `4) Location\n` +
            `5) Downstack\n` +
            `6) Notes\n\n` +
            `Enter a number 1-6:`
        );
        if (!choice) return;
        const num = parseInt(choice, 10);
        if (isNaN(num) || num < 1 || num > 6) {
            alert('Invalid choice.');
            return;
        }

        let targetField;
        switch (num) {
            case 1: targetField = field1; break;
            case 2: targetField = field2; break;
            case 3: targetField = field3; break;
            case 4: targetField = field4; break;
            case 5: targetField = field5; break;
            case 6: targetField = field6; break;
        }

        targetField.value = text;
    }

    // Function to Perform OCR using the Postprocessed Image
    // Already updated imageDataURL to postprocessed image

    /* -------------------- Postprocessing Integration -------------------- */

    // Function to Apply Postprocessing Effects (Defined Above)
    // Already implemented above

    /* -------------------- End of Postprocessing Integration -------------------- */

</script>
    
</body>
</html>
