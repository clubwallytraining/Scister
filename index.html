<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OCR Image Processor with Clickable Text Highlights and Crop Feature</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tesseract.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    <style>
        /* General Styles */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            overflow: hidden; /* Prevent default scrolling */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        h1 {
            font-size: 24px;
            margin: 20px;
            text-align: center;
            color: #fff;
        }
        p {
            margin: 0 20px 20px 20px;
            text-align: center;
            line-height: 1.5;
            color: #ccc;
        }

        /* Side Menu Styles */
        #sideMenu {
            height: 100%; /* Full-height */
            width: 250px; /* Width of the side menu */
            position: fixed; /* Stay in place */
            top: 0;
            left: -250px; /* Hidden by default */
            background-color: #1e1e1e; /* Dark background */
            overflow-x: hidden; /* Disable horizontal scroll */
            transition: 0.3s; /* Transition effect */
            padding-top: 60px; /* Place content 60px from the top */
            z-index: 1000; /* Stay on top */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #sideMenu button {
            padding: 12px 20px;
            width: 90%;
            margin: 10px 0;
            background-color: #333;
            color: #e0e0e0;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        #sideMenu button:hover {
            background-color: #444;
            transform: translateX(5px);
        }

        /* Hamburger Menu Button Styles */
        #hamburgerBtn {
            position: fixed; /* Fixed position */
            top: 20px;
            left: 20px;
            z-index: 1100; /* Above side menu */
            width: 40px;
            height: 40px;
            background-color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }
        #hamburgerBtn:hover {
            background-color: #444;
        }
        /* Hamburger Icon */
        .bar {
            display: block;
            width: 22px;
            height: 3px;
            background-color: #e0e0e0;
            margin: 4px 0;
            transition: 0.4s;
        }

        /* Side Menu Active State */
        #sideMenu.active {
            left: 0; /* Show the side menu */
        }

        /* Image Container Styles */
        .input-section {
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            width: 100%;
            max-width: 800px;
        }
        .input-section label {
            display: block;
            margin: 10px 0 5px 0;
            font-weight: bold;
            color: #fff;
        }
        #imageInput {
            margin-bottom: 10px;
            width: 80%;
            padding: 10px;
            box-sizing: border-box;
            border: none;
            border-radius: 4px;
            background-color: #2c2c2c;
            color: #e0e0e0;
            cursor: pointer;
        }
        #imageInput::file-selector-button {
            background-color: #555;
            color: #e0e0e0;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #imageInput::file-selector-button:hover {
            background-color: #666;
        }
        #imageContainer {
            position: relative;
            display: none;
            margin: 0 auto;
            max-width: 100%;
            border: 2px solid #333;
            border-radius: 8px;
        }
        #uploadedImage {
            display: block;
            max-width: 100%;
            border-radius: 8px;
        }
        /* Canvas Styles */
        #postprocessingCanvas, #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 8px;
        }
        #postprocessingCanvas {
            z-index: 5; /* Below overlayCanvas */
            pointer-events: none; /* Allow clicks to pass through */
        }
        #overlayCanvas {
            z-index: 10;
            pointer-events: auto;
        }

        /* Status Message */
        #statusMessage {
            font-size: 14px;
            color: #b0b0b0;
            margin-top: 10px;
        }

        /* Field Container */
        #fieldContainer {
            margin: 20px auto;
            padding: 0 20px;
            max-width: 800px;
            display: flex;
            flex-direction: column;
        }
        #fieldContainer label {
            font-weight: bold;
            margin: 10px 0 5px 0;
            color: #fff;
        }
        #fieldContainer input[type="text"] {
            padding: 10px;
            margin-bottom: 10px;
            border: none;
            border-radius: 4px;
            background-color: #2c2c2c;
            color: #e0e0e0;
            box-sizing: border-box;
        }

        /* Postprocessing Controls */
        .postprocessing-controls {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            width: 90%;
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        .postprocessing-controls label {
            width: 100%;
            margin: 8px 0 4px 0;
            text-align: left;
            color: #e0e0e0;
        }
        .postprocessing-controls input[type="range"],
        .postprocessing-controls input[type="checkbox"] {
            width: 100%;
            margin-bottom: 10px;
        }

        /* Action Buttons */
        .buttons-container {
            display: flex;
            justify-content: center;
            margin: 20px;
        }
        .buttons-container button {
            padding: 10px 15px;
            margin: 0 10px;
            cursor: pointer;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
            color: #fff;
        }
        #perform-ocr {
            background-color: #2cb67d;
        }
        #perform-ocr:hover {
            background-color: #28a46e;
        }
        #clear-image {
            background-color: #d00000;
        }
        #clear-image:hover {
            background-color: #b00000;
        }
        #update-table {
            background-color: #3498db;
        }
        #update-table:hover {
            background-color: #2980b9;
        }
        #save-csv {
            background-color: #f39c12;
        }
        #save-csv:hover {
            background-color: #d68910;
        }

        /* Data Table */
        #dataTable {
            width: 90%;
            max-width: 1000px;
            margin: 0 auto 20px auto;
            border-collapse: collapse;
            background-color: #1e1e1e;
            border-radius: 8px;
            overflow: hidden;
        }
        #dataTable th, #dataTable td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        #dataTable th {
            background-color: #333;
            color: #e0e0e0;
        }
        #dataTable tr:hover {
            background-color: #2a2a2a;
        }

        /* Scroll Buttons Container */
        .scroll-buttons {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        /* Scroll Buttons Styles */
        .scroll-button {
            background-color: #555;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px 10px;
            transition: background-color 0.3s, transform 0.2s;
            color: #e0e0e0;
            cursor: pointer;
            border: none;
        }
        .scroll-button:hover {
            background-color: #666;
            transform: translateY(-2px);
        }

        /* Ensure side menu is scrollable if content overflows */
        #sideMenu {
            overflow-y: auto;
        }

        /* Prevent main container from being hidden under fixed side menu */
        .container {
            margin-left: 0; /* Adjusted dynamically via JavaScript if needed */
        }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            #sideMenu {
                width: 200px;
            }
            #hamburgerBtn {
                width: 35px;
                height: 35px;
            }
            #sideMenu button {
                font-size: 14px;
                padding: 10px 15px;
            }
            .scroll-button {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        /* Highlighted Rectangle Style */
        .highlighted-rect {
            border: 2px solid #00FFFF; /* Cyan */
            background-color: rgba(0, 255, 255, 0.3); /* Cyan with transparency */
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Hamburger Menu Button -->
    <button id="hamburgerBtn" aria-label="Toggle Side Menu">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
    </button>

    <!-- Side Menu -->
    <div id="sideMenu">
        <button id="draw-button">Draw</button>
        <button id="undo-draw-button" style="display:none;">Undo Draw</button>
        <button id="crop-button">Crop</button>
        <button id="confirm-crop-button" style="display:none;">Confirm Crop</button>
        <button id="perform-ocr-button">Perform OCR</button>
        <button id="clear-image-button">Clear Image & Fields</button>
        <button id="update-table-button">Update Table</button>
        <button id="save-csv-button">Save CSV</button>

        <!-- Postprocessing Submenu -->
        <button id="postprocessing-button">Postprocessing</button>
        <div class="postprocessing-controls" id="postprocessing-controls">
            <label for="grayscale">Grayscale:</label>
            <input type="checkbox" id="grayscale">

            <label for="highlight">Highlight:</label>
            <input type="range" id="highlight" min="0" max="100" value="0">

            <label for="clarity">Clarity:</label>
            <input type="range" id="clarity" min="0" max="100" value="50">

            <label for="brightness">Brightness:</label>
            <input type="range" id="brightness" min="-100" max="100" value="0">

            <label for="sharpening">Sharpening:</label>
            <input type="range" id="sharpening" min="0" max="100" value="0">
        </div>

        <!-- Scroll Buttons -->
        <div class="scroll-buttons">
            <button id="scroll-up-button" class="scroll-button" aria-label="Scroll Up">&#9650;</button>
            <button id="scroll-down-button" class="scroll-button" aria-label="Scroll Down">&#9660;</button>
        </div>
    </div>

    <h1>OCR Image Processor with Clickable Text Highlights and Crop Feature</h1>
    <p>Upload an image and perform OCR. Use the side menu to select specific areas for OCR or to crop the image. After drawing a crop rectangle, click "Confirm Crop" to apply the crop. Recognized words within drawn rectangles will be highlighted in blue on the image. Click on a highlighted block to assign the concatenated text to one of the input fields (Item Name Short, Item Name Long, UPC, Location, Downstack, Notes). You can edit fields manually as well. Once done, press "Update Table" to add a row to the table. Process multiple images by clearing the image and fields. Finally, press "Save CSV" to download all collected data.</p>

    <!-- Main Input Section -->
    <div class="input-section">
        <label for="imageInput">Upload Image:</label>
        <input type="file" id="imageInput" accept="image/*">
        <div id="imageContainer">
            <img id="uploadedImage" alt="Uploaded Image">
            <!-- Postprocessing Canvas -->
            <canvas id="postprocessingCanvas"></canvas>
            <!-- Overlay Canvas for Drawing -->
            <canvas id="overlayCanvas"></canvas>
        </div>
        <p id="statusMessage"></p>
        <button id="perform-ocr-button">Perform OCR</button>
        <button id="clear-image-button">Clear Image & Fields</button>
    </div>

    <!-- Input Fields -->
    <div id="fieldContainer">
        <label for="field1">Item Name Short:</label>
        <input type="text" id="field1">
        <label for="field2">Item Name Long:</label>
        <input type="text" id="field2">
        <label for="field3">UPC:</label>
        <input type="text" id="field3">
        <label for="field4">Location:</label>
        <input type="text" id="field4">
        <label for="field5">Downstack:</label>
        <input type="text" id="field5">
        <label for="field6">Notes:</label>
        <input type="text" id="field6">
    </div>

    <!-- Action Buttons -->
    <div class="buttons-container">
        <button id="update-table-button">Update Table</button>
        <button id="save-csv-button">Save CSV</button>
    </div>

    <!-- Data Table -->
    <table id="dataTable">
        <thead>
            <tr>
                <th>Item Name Short</th>
                <th>Item Name Long</th>
                <th>UPC</th>
                <th>Location</th>
                <th>Downstack</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <!-- Rows will be appended here -->
        </tbody>
    </table>

    <script>
        // DOM Elements
        const imageInput = document.getElementById('imageInput');
        const uploadedImage = document.getElementById('uploadedImage');
        const imageContainer = document.getElementById('imageContainer');
        const overlayCanvas = document.getElementById('overlayCanvas');
        const postprocessingCanvas = document.getElementById('postprocessingCanvas');
        const performOcrButton = document.getElementById('perform-ocr-button');
        const clearImageButton = document.getElementById('clear-image-button');
        const statusMessage = document.getElementById('statusMessage');
        const dataTable = document.getElementById('dataTable').querySelector('tbody');

        // Side Menu Buttons
        const drawButton = document.getElementById('draw-button');
        const undoDrawButton = document.getElementById('undo-draw-button');
        const cropButton = document.getElementById('crop-button');
        const confirmCropButton = document.getElementById('confirm-crop-button');

        // Postprocessing Controls
        const postprocessingButton = document.getElementById('postprocessing-button');
        const postprocessingControls = document.getElementById('postprocessing-controls');
        const grayscaleCheckbox = document.getElementById('grayscale');
        const highlightSlider = document.getElementById('highlight');
        const claritySlider = document.getElementById('clarity');
        const brightnessSlider = document.getElementById('brightness');
        const sharpeningSlider = document.getElementById('sharpening');

        // Input Fields
        const field1 = document.getElementById('field1');
        const field2 = document.getElementById('field2');
        const field3 = document.getElementById('field3');
        const field4 = document.getElementById('field4');
        const field5 = document.getElementById('field5');
        const field6 = document.getElementById('field6');

        // Action Buttons
        const updateTableButton = document.getElementById('update-table-button');
        const saveCsvButton = document.getElementById('save-csv-button');

        // Hamburger Menu Button
        const hamburgerBtn = document.getElementById('hamburgerBtn');
        const sideMenu = document.getElementById('sideMenu');

        // State Variables
        let ocrRectangles = []; // Store user-drawn rectangles for OCR
        let cropRect = null; // Single crop rectangle
        let isDrawingMode = false;
        let isCroppingMode = false;
        let isDrawing = false;
        let isResizing = false;
        let activeHandle = null;
        let resizeTarget = null; // The rectangle being resized
        let startX = 0;
        let startY = 0;
        let currentRect = null;
        let wordGroups = []; // Each group has {text: '...', x, y, width, height}
        let scale = 1; // Scaling factor (naturalWidth / clientWidth)

        // Scroll Buttons
        const scrollUpButton = document.getElementById('scroll-up-button');
        const scrollDownButton = document.getElementById('scroll-down-button');

        // Resize Handle Size
        let HANDLE_SIZE = 10;

        // Scroll Buttons Functionality
        scrollUpButton.addEventListener('click', () => {
            window.scrollBy({ top: -500, left: 0, behavior: 'smooth' });
        });
        scrollDownButton.addEventListener('click', () => {
            window.scrollBy({ top: 500, left: 0, behavior: 'smooth' });
        });

        // Side Menu Toggle Function
        function toggleSideMenu() {
            sideMenu.classList.toggle('active');
        }

        // Event Listener for Hamburger Button
        hamburgerBtn.addEventListener('click', toggleSideMenu);

        // Close Side Menu on Escape Key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && sideMenu.classList.contains('active')) {
                sideMenu.classList.remove('active');
            }
        });

        // Close Side Menu When Clicking Outside
        window.addEventListener('click', (e) => {
            if (!sideMenu.contains(e.target) && e.target !== hamburgerBtn) {
                if (sideMenu.classList.contains('active')) {
                    sideMenu.classList.remove('active');
                }
            }
        });

        // Close Side Menu After Clicking a Button
        sideMenu.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => {
                sideMenu.classList.remove('active');
            });
        });

        // Event Listener for Postprocessing Button to Toggle Controls
        postprocessingButton.addEventListener('click', () => {
            postprocessingControls.style.display = postprocessingControls.style.display === 'flex' ? 'none' : 'flex';
        });

        // Adjust Canvas for High-DPI Displays and Responsive Sizing
        function adjustCanvas() {
            const ratio = window.devicePixelRatio || 1;

            // Adjust postprocessingCanvas
            postprocessingCanvas.width = uploadedImage.clientWidth * ratio;
            postprocessingCanvas.height = uploadedImage.clientHeight * ratio;
            postprocessingCanvas.style.width = `${uploadedImage.clientWidth}px`;
            postprocessingCanvas.style.height = `${uploadedImage.clientHeight}px`;
            const ppCtx = postprocessingCanvas.getContext('2d');
            ppCtx.scale(ratio, ratio);

            // Adjust overlayCanvas
            overlayCanvas.width = uploadedImage.clientWidth * ratio;
            overlayCanvas.height = uploadedImage.clientHeight * ratio;
            overlayCanvas.style.width = `${uploadedImage.clientWidth}px`;
            overlayCanvas.style.height = `${uploadedImage.clientHeight}px`;
            const ovCtx = overlayCanvas.getContext('2d');
            ovCtx.scale(ratio, ratio);

            // Calculate uniform scaling factor based on natural size
            scale = uploadedImage.naturalWidth / uploadedImage.clientWidth;

            // After adjusting, redraw postprocessing and overlay
            applyPostprocessing();
            redrawCanvas();
        }

        // Update Handle Size Based on Screen Width
        function updateHandleSize() {
            if (window.innerWidth <= 600) {
                HANDLE_SIZE = 20; // Larger handles for mobile
            } else {
                HANDLE_SIZE = 10; // Default size for desktop
            }
            redrawCanvas(); // Redraw to apply new handle sizes
        }

        // Call updateHandleSize on Initial Load and on Window Resize
        window.addEventListener('load', () => {
            updateHandleSize();
            // Also apply postprocessing if image is already loaded
            if (uploadedImage.complete && uploadedImage.naturalWidth !== 0) {
                applyPostprocessing();
            }
        });
        window.addEventListener('resize', () => {
            adjustCanvas();
            updateHandleSize();
        });

        // Event Listener for Image Upload
        imageInput.addEventListener('change', () => {
            const file = imageInput.files[0];
            if (!file) {
                resetImageDisplay();
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedImage.src = e.target.result;
                uploadedImage.onload = () => {
                    imageContainer.style.display = 'block';
                    
                    adjustCanvas();

                    clearCanvas();
                    statusMessage.textContent = 'Image loaded. You can crop or draw on the image.';
                    ocrRectangles = [];
                    wordGroups = [];
                    cropRect = null;
                    isDrawingMode = false;
                    isCroppingMode = false;
                    drawButton.textContent = 'Draw';
                    cropButton.textContent = 'Crop';
                    confirmCropButton.style.display = 'none';
                    undoDrawButton.style.display = 'none'; // Hide Undo Draw initially
                    redrawCanvas();

                    // Apply postprocessing after image is loaded
                    applyPostprocessing();
                };
            };
            reader.readAsDataURL(file);
        });

        // Event Listener for Draw Button
        drawButton.addEventListener('click', () => {
            if (!uploadedImage.src) {
                alert('Please upload an image first.');
                return;
            }
            if (isCroppingMode) {
                // If cropping mode is active, deactivate it
                isCroppingMode = false;
                cropButton.textContent = 'Crop';
                confirmCropButton.style.display = 'none';
            }
            isDrawingMode = !isDrawingMode;
            if (isDrawingMode) {
                drawButton.textContent = 'Cancel Draw';
                statusMessage.textContent = 'Draw mode activated. Click and drag on the image to draw rectangles for OCR.';
                // Clear crop rectangle if any
                cropRect = null;
                confirmCropButton.style.display = 'none';
                undoDrawButton.style.display = ocrRectangles.length > 0 ? 'inline-block' : 'none';
                redrawCanvas();
            } else {
                drawButton.textContent = 'Draw';
                statusMessage.textContent = 'Draw mode deactivated.';
                currentRect = null;
                redrawCanvas();
            }
        });

        // Event Listener for Crop Button
        cropButton.addEventListener('click', () => {
            if (!uploadedImage.src) {
                alert('Please upload an image first.');
                return;
            }
            if (isDrawingMode) {
                // If draw mode is active, deactivate it
                isDrawingMode = false;
                drawButton.textContent = 'Draw';
            }
            isCroppingMode = !isCroppingMode;
            if (isCroppingMode) {
                cropButton.textContent = 'Cancel Crop';
                statusMessage.textContent = 'Crop mode activated. Click and drag on the image to select the crop area.';
                // Clear existing crop rectangle
                cropRect = null;
                confirmCropButton.style.display = 'none';
                undoDrawButton.style.display = 'none';
                redrawCanvas();
            } else {
                cropButton.textContent = 'Crop';
                statusMessage.textContent = 'Crop mode deactivated.';
                currentRect = null;
                confirmCropButton.style.display = 'none';
                redrawCanvas();
            }
        });

        // Event Listener for Confirm Crop Button
        confirmCropButton.addEventListener('click', () => {
            if (!cropRect) {
                alert('Please draw a crop rectangle first.');
                return;
            }
            performCrop(cropRect);
            // After cropping, hide the Confirm Crop button and deactivate crop mode
            isCroppingMode = false;
            cropButton.textContent = 'Crop';
            confirmCropButton.style.display = 'none';
            statusMessage.textContent = 'Image cropped successfully.';
            redrawCanvas();
        });

        // Event Listener for Undo Draw Button
        undoDrawButton.addEventListener('click', () => {
            if (ocrRectangles.length === 0) {
                alert('No rectangles to undo.');
                return;
            }
            ocrRectangles.pop();
            redrawCanvas();
            statusMessage.textContent = 'Last drawn rectangle has been removed.';
            undoDrawButton.style.display = ocrRectangles.length > 0 ? 'inline-block' : 'none';
        });

        // Mouse Events for Desktop Drawing/Cropping and Resizing
        overlayCanvas.addEventListener('mousedown', (e) => {
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            const handleInfo = getHandleAt(x, y);
            if (handleInfo) {
                isResizing = true;
                activeHandle = handleInfo.type;
                resizeTarget = handleInfo.rect === 'crop' ? 'crop' : handleInfo.index;
                return;
            }

            if (isDrawingMode || isCroppingMode) {
                isDrawing = true;
                startX = x;
                startY = y;
                currentRect = { x: startX, y: startY, width: 0, height: 0 };
            }
        });

        overlayCanvas.addEventListener('mousemove', (e) => {
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            if (isResizing) {
                resizeRectangle(x, y);
                redrawCanvas();
                return;
            }

            if (isDrawing && currentRect) {
                currentRect.width = x - startX;
                currentRect.height = y - startY;
                redrawCanvas();
                const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
                drawRectangle(currentRect, style.fill, style.stroke);
            }
        });

        overlayCanvas.addEventListener('mouseup', (e) => {
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            if (isResizing) {
                isResizing = false;
                activeHandle = null;
                resizeTarget = null;
                statusMessage.textContent = 'Rectangle resized.';
                return;
            }

            if (isDrawing && currentRect) {
                isDrawing = false;
                const normalizedRect = normalizeRect(currentRect);
                if (isDrawingMode) {
                    ocrRectangles.push(normalizedRect);
                    statusMessage.textContent = `${ocrRectangles.length} OCR rectangle(s) drawn.`;
                    undoDrawButton.style.display = ocrRectangles.length > 0 ? 'inline-block' : 'none';
                } else if (isCroppingMode) {
                    if (cropRect) {
                        // Replace existing cropRect
                        cropRect = normalizedRect;
                        statusMessage.textContent = 'Crop rectangle updated. You can resize or confirm the crop.';
                    } else {
                        cropRect = normalizedRect;
                        statusMessage.textContent = 'Crop rectangle drawn. You can resize it using the handles or confirm the crop.';
                    }
                    // Show Confirm Crop button
                    confirmCropButton.style.display = 'inline-block';
                }
                currentRect = null;
                redrawCanvas();
            }
        });

        // Touch Events for Mobile Drawing/Cropping and Resizing
        overlayCanvas.addEventListener('touchstart', (e) => {
            if (!(isDrawingMode || isCroppingMode)) return;
            e.preventDefault(); // Prevent scrolling
            if (e.touches.length !== 1) return; // Only single touch
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.touches[0].clientX - rect.left) * scale;
            const y = (e.touches[0].clientY - rect.top) * scale;

            const handleInfo = getHandleAt(x, y);
            if (handleInfo) {
                isResizing = true;
                activeHandle = handleInfo.type;
                resizeTarget = handleInfo.rect === 'crop' ? 'crop' : handleInfo.index;
                return;
            }

            if (isDrawingMode || isCroppingMode) {
                isDrawing = true;
                startX = x;
                startY = y;
                currentRect = { x: startX, y: startY, width: 0, height: 0 };
            }
        }, { passive: false });

        overlayCanvas.addEventListener('touchmove', (e) => {
            if (!(isDrawingMode || isCroppingMode)) return;
            e.preventDefault(); // Prevent scrolling
            if (e.touches.length !== 1) return; // Only single touch
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.touches[0].clientX - rect.left) * scale;
            const y = (e.touches[0].clientY - rect.top) * scale;

            if (isResizing) {
                resizeRectangle(x, y);
                redrawCanvas();
                return;
            }

            if (isDrawing && currentRect) {
                currentRect.width = x - startX;
                currentRect.height = y - startY;
                redrawCanvas();
                const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
                drawRectangle(currentRect, style.fill, style.stroke);
            }
        }, { passive: false });

        overlayCanvas.addEventListener('touchend', (e) => {
            if (!(isDrawingMode || isCroppingMode)) return;
            if (isResizing) {
                isResizing = false;
                activeHandle = null;
                resizeTarget = null;
                statusMessage.textContent = 'Rectangle resized.';
                return;
            }

            if (isDrawing && currentRect) {
                isDrawing = false;
                const normalizedRect = normalizeRect(currentRect);
                if (isDrawingMode) {
                    ocrRectangles.push(normalizedRect);
                    statusMessage.textContent = `${ocrRectangles.length} OCR rectangle(s) drawn.`;
                    undoDrawButton.style.display = ocrRectangles.length > 0 ? 'inline-block' : 'none';
                } else if (isCroppingMode) {
                    if (cropRect) {
                        // Replace existing cropRect
                        cropRect = normalizedRect;
                        statusMessage.textContent = 'Crop rectangle updated. You can resize or confirm the crop.';
                    } else {
                        cropRect = normalizedRect;
                        statusMessage.textContent = 'Crop rectangle drawn. You can resize it using the handles or confirm the crop.';
                    }
                    // Show Confirm Crop button
                    confirmCropButton.style.display = 'inline-block';
                }
                currentRect = null;
                redrawCanvas();
            }
        });

        // Function to Get Handle Positions Relative to the Rectangle
        function getHandlePositions(rect) {
            return {
                nw: { x: rect.x, y: rect.y },
                n: { x: rect.x + rect.width / 2, y: rect.y },
                ne: { x: rect.x + rect.width, y: rect.y },
                e: { x: rect.x + rect.width, y: rect.y + rect.height / 2 },
                se: { x: rect.x + rect.width, y: rect.y + rect.height },
                s: { x: rect.x + rect.width / 2, y: rect.y + rect.height },
                sw: { x: rect.x, y: rect.y + rect.height },
                w: { x: rect.x, y: rect.y + rect.height / 2 }
            };
        }

        // Function to Draw a Rectangle
        function drawRectangle(rect, fillStyle, strokeStyle) {
            const ctx = overlayCanvas.getContext('2d');
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 2;
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }

        // Function to Draw Resize Handles for a Rectangle
        function drawHandles(rect) {
            const ctx = overlayCanvas.getContext('2d');
            const handles = getHandlePositions(rect);
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            for (let key in handles) {
                const pos = handles[key];
                ctx.fillRect(pos.x - HANDLE_SIZE / 2, pos.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                ctx.strokeRect(pos.x - HANDLE_SIZE / 2, pos.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
            }
        }

        // Function to Check if Point is Inside Any Handle of Any Rectangle
        function getHandleAt(x, y) {
            // Check cropRect first
            if (cropRect) {
                const handles = getHandlePositions(cropRect);
                for (let key in handles) {
                    const pos = handles[key];
                    if (
                        x >= pos.x - HANDLE_SIZE / 2 &&
                        x <= pos.x + HANDLE_SIZE / 2 &&
                        y >= pos.y - HANDLE_SIZE / 2 &&
                        y <= pos.y + HANDLE_SIZE / 2
                    ) {
                        return { type: key, rect: 'crop' };
                    }
                }
            }

            // Check ocrRectangles
            for (let i = 0; i < ocrRectangles.length; i++) {
                const rect = ocrRectangles[i];
                const handles = getHandlePositions(rect);
                for (let key in handles) {
                    const pos = handles[key];
                    if (
                        x >= pos.x - HANDLE_SIZE / 2 &&
                        x <= pos.x + HANDLE_SIZE / 2 &&
                        y >= pos.y - HANDLE_SIZE / 2 &&
                        y <= pos.y + HANDLE_SIZE / 2
                    ) {
                        return { type: key, rect: 'ocr', index: i };
                    }
                }
            }

            return null;
        }

        // Function to Normalize Rectangle (handles negative width/height)
        function normalizeRect(rect) {
            let { x, y, width, height } = rect;
            if (width < 0) {
                x += width;
                width = Math.abs(width);
            }
            if (height < 0) {
                y += height;
                height = Math.abs(height);
            }
            // Ensure rectangle stays within image boundaries
            x = Math.max(0, x);
            y = Math.max(0, y);
            width = Math.min(width, uploadedImage.clientWidth - x);
            height = Math.min(height, uploadedImage.clientHeight - y);
            return { x, y, width, height };
        }

        // Function to Resize Rectangle
        function resizeRectangle(x, y) {
            if (resizeTarget === 'crop') {
                if (!cropRect || !activeHandle) return;
                switch (activeHandle) {
                    case 'nw':
                        cropRect.width += cropRect.x - x;
                        cropRect.height += cropRect.y - y;
                        cropRect.x = x;
                        cropRect.y = y;
                        break;
                    case 'n':
                        cropRect.height += cropRect.y - y;
                        cropRect.y = y;
                        break;
                    case 'ne':
                        cropRect.width = x - cropRect.x;
                        cropRect.height += cropRect.y - y;
                        cropRect.y = y;
                        break;
                    case 'e':
                        cropRect.width = x - cropRect.x;
                        break;
                    case 'se':
                        cropRect.width = x - cropRect.x;
                        cropRect.height = y - cropRect.y;
                        break;
                    case 's':
                        cropRect.height = y - cropRect.y;
                        break;
                    case 'sw':
                        cropRect.width += cropRect.x - x;
                        cropRect.height = y - cropRect.y;
                        cropRect.x = x;
                        break;
                    case 'w':
                        cropRect.width += cropRect.x - x;
                        cropRect.x = x;
                        break;
                }

                // Normalize the rectangle to prevent negative width/height and stay within image boundaries
                cropRect = normalizeRect(cropRect);
            } else if (typeof resizeTarget === 'number') {
                const rect = ocrRectangles[resizeTarget];
                if (!rect || !activeHandle) return;

                switch (activeHandle) {
                    case 'nw':
                        rect.width += rect.x - x;
                        rect.height += rect.y - y;
                        rect.x = x;
                        rect.y = y;
                        break;
                    case 'n':
                        rect.height += rect.y - y;
                        rect.y = y;
                        break;
                    case 'ne':
                        rect.width = x - rect.x;
                        rect.height += rect.y - y;
                        rect.y = y;
                        break;
                    case 'e':
                        rect.width = x - rect.x;
                        break;
                    case 'se':
                        rect.width = x - rect.x;
                        rect.height = y - rect.y;
                        break;
                    case 's':
                        rect.height = y - rect.y;
                        break;
                    case 'sw':
                        rect.width += rect.x - x;
                        rect.height = y - rect.y;
                        rect.x = x;
                        break;
                    case 'w':
                        rect.width += rect.x - x;
                        rect.x = x;
                        break;
                }

                // Normalize the rectangle to prevent negative width/height and stay within image boundaries
                ocrRectangles[resizeTarget] = normalizeRect(rect);
            }
        }

        // Function to Perform Cropping
        function performCrop(rect) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Calculate scaling factors
            const scaleX = uploadedImage.naturalWidth / uploadedImage.clientWidth;
            const scaleY = uploadedImage.naturalHeight / uploadedImage.clientHeight;

            // Define the crop area on the original image
            const cropX = rect.x * scaleX;
            const cropY = rect.y * scaleY;
            const cropWidth = rect.width * scaleX;
            const cropHeight = rect.height * scaleY;

            canvas.width = cropWidth;
            canvas.height = cropHeight;

            ctx.drawImage(uploadedImage, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
            const croppedDataURL = canvas.toDataURL();

            // Update the image source
            uploadedImage.src = croppedDataURL;
            imageDataURL = croppedDataURL;

            // Adjust canvas for the new image size
            uploadedImage.onload = () => {
                adjustCanvas();
                clearCanvas();
                // Reset any previous drawings
                ocrRectangles = [];
                wordGroups = [];
                cropRect = null;
                statusMessage.textContent = 'Image cropped successfully. You can now draw OCR rectangles.';
                undoDrawButton.style.display = 'none';
                redrawCanvas();

                // Apply postprocessing after cropping
                applyPostprocessing();
            };
        }

        // Perform OCR Button
        performOcrButton.addEventListener('click', async () => {
            if (!uploadedImage.src) {
                alert('Please upload an image first.');
                return;
            }
            if (ocrRectangles.length === 0) {
                alert('Please draw at least one rectangle to select OCR areas.');
                return;
            }

            // Programmatically exit draw mode
            if (isDrawingMode) {
                drawButton.click();
            }

            statusMessage.textContent = 'Performing OCR... please wait.';
            performOcrButton.disabled = true;
            performOcrButton.textContent = 'Processing...';

            // Perform OCR on each rectangle
            wordGroups = [];
            for (let i = 0; i < ocrRectangles.length; i++) {
                const rect = ocrRectangles[i];
                const extractedText = await extractTextFromRect(rect);
                if (extractedText.trim() !== '') {
                    wordGroups.push({
                        text: extractedText,
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height
                    });
                }
            }

            statusMessage.textContent = 'OCR complete. Click on highlighted blocks to assign fields.';
            performOcrButton.disabled = false;
            performOcrButton.textContent = 'Perform OCR';
            redrawCanvas();
        });

        // Function to Extract Text from a Rectangle using Tesseract.js
        async function extractTextFromRect(rect) {
            // Create a temporary canvas to extract the rectangle area
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const scaleFactorX = uploadedImage.naturalWidth / uploadedImage.clientWidth;
            const scaleFactorY = uploadedImage.naturalHeight / uploadedImage.clientHeight;

            tempCanvas.width = rect.width * scaleFactorX;
            tempCanvas.height = rect.height * scaleFactorY;

            tempCtx.drawImage(
                uploadedImage,
                rect.x * scaleFactorX,
                rect.y * scaleFactorY,
                rect.width * scaleFactorX,
                rect.height * scaleFactorY,
                0,
                0,
                rect.width * scaleFactorX,
                rect.height * scaleFactorY
            );

            const dataURL = tempCanvas.toDataURL();

            // Perform OCR on the extracted area
            const worker = await Tesseract.createWorker({
                logger: m => console.log(m)
            });
            await worker.load();
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            const { data } = await worker.recognize(dataURL);
            await worker.terminate();

            return data.text;
        }

        // Function to Assign Group Text to a Field
        function assignGroupToField(text) {
            const choice = prompt(
                `Choose a field to assign this text:\n` +
                `1) Item Name Short\n` +
                `2) Item Name Long\n` +
                `3) UPC\n` +
                `4) Location\n` +
                `5) Downstack\n` +
                `6) Notes\n\n` +
                `Enter a number 1-6:`
            );
            if (!choice) return; // User canceled
            const num = parseInt(choice, 10);
            if (isNaN(num) || num < 1 || num > 6) {
                alert('Invalid choice.');
                return;
            }

            let targetField;
            switch (num) {
                case 1: targetField = field1; break;
                case 2: targetField = field2; break;
                case 3: targetField = field3; break;
                case 4: targetField = field4; break;
                case 5: targetField = field5; break;
                case 6: targetField = field6; break;
            }

            targetField.value = text;
        }

        // Function to Handle Clicks on Highlighted Blocks
        overlayCanvas.addEventListener('click', (e) => {
            if (wordGroups.length === 0) return;
            const rect = overlayCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            for (let group of wordGroups) {
                if (x >= group.x && x <= group.x + group.width && y >= group.y && y <= group.y + group.height) {
                    assignGroupToField(group.text);
                    break;
                }
            }
        });

        // Function to Run OCR using Tesseract.js
        // Already implemented above

        // Function to Process OCR Data and Group Words within Rectangles
        // Already implemented via wordGroups

        // Function to Assign Text to Fields
        // Already handled via assignGroupToField

        // Function to Reset Image Display
        function resetImageDisplay() {
            uploadedImage.src = '';
            imageContainer.style.display = 'none';
            imageDataURL = null;
            clearCanvas();
            ocrRectangles = [];
            wordGroups = [];
            cropRect = null;
            isDrawingMode = false;
            isCroppingMode = false;
            drawButton.textContent = 'Draw';
            cropButton.textContent = 'Crop';
            confirmCropButton.style.display = 'none';
            undoDrawButton.style.display = 'none';
            statusMessage.textContent = '';
            redrawCanvas();

            // Clear postprocessing canvas
            const ppCtx = postprocessingCanvas.getContext('2d');
            ppCtx.clearRect(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);
        }

        // Function to Reset Input Fields
        function resetFields() {
            field1.value = '';
            field2.value = '';
            field3.value = '';
            field4.value = '';
            field5.value = '';
            field6.value = '';
        }

        // Function to Clear Canvas
        function clearCanvas() {
            const ctx = overlayCanvas.getContext('2d');
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        }

        // Function to Redraw Canvas
        function redrawCanvas() {
            clearCanvas();
            const ctx = overlayCanvas.getContext('2d');

            // Draw existing OCR rectangles
            ocrRectangles.forEach((rect, index) => {
                drawRectangle(rect, 'rgba(255, 0, 0, 0.3)', 'red');
                if (isDrawingMode || isCroppingMode) {
                    drawHandles(rect);
                }
            });

            // Draw crop rectangle if any
            if (cropRect) {
                drawRectangle(cropRect, 'rgba(0, 150, 255, 0.25)', 'rgba(0, 150, 255, 1)');
                if (isCroppingMode) {
                    drawHandles(cropRect);
                }
            }

            // Draw word groups
            wordGroups.forEach(group => {
                drawRectangle(group, 'rgba(0, 255, 255, 0.3)', '#00FFFF'); // Blue rectangles
            });

            // Draw current rectangle if any
            if (currentRect) {
                const style = isDrawingMode ? { fill: 'rgba(255, 0, 0, 0.3)', stroke: 'red' } : { fill: 'rgba(0, 150, 255, 0.25)', stroke: 'rgba(0, 150, 255, 1)' };
                drawRectangle(currentRect, style.fill, style.stroke);
            }
        }

        // Function to Assign Text to Fields
        // Already handled via assignGroupToField

        // Function to Prevent Scrolling When Touching the Canvas in Draw or Crop Mode
        document.body.addEventListener('touchstart', function(e) {
            if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchend', function(e) {
            if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
                e.preventDefault();
            }
        }, { passive: false });

        document.body.addEventListener('touchmove', function(e) {
            if ((isDrawingMode || isCroppingMode) && e.target === overlayCanvas) {
                e.preventDefault();
            }
        }, { passive: false });
        
        /* -------------------- Postprocessing Functions -------------------- */

        // Function to Apply Postprocessing Effects
        function applyPostprocessing() {
            if (!uploadedImage.src) return;

            const ppCtx = postprocessingCanvas.getContext('2d');
            const ovCtx = overlayCanvas.getContext('2d');

            // Clear Postprocessing Canvas
            ppCtx.clearRect(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);

            // Draw the uploaded image onto Postprocessing Canvas
            ppCtx.drawImage(uploadedImage, 0, 0, uploadedImage.clientWidth, uploadedImage.clientHeight);

            // Get ImageData
            let imageData = ppCtx.getImageData(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);
            let data = imageData.data;

            // Apply Grayscale
            if (grayscaleCheckbox.checked) {
                for (let i = 0; i < data.length; i += 4) {
                    const avg = 0.3 * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
                    data[i] = data[i + 1] = data[i + 2] = avg;
                }
            }

            // Apply Brightness
            const brightnessValue = parseInt(brightnessSlider.value, 10); // Range: -100 to 100
            if (brightnessValue !== 0) {
                const factor = brightnessValue;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] += factor;
                    data[i + 1] += factor;
                    data[i + 2] += factor;
                }
            }

            // Apply Clarity (Implemented as Contrast Adjustment)
            const clarityValue = parseInt(claritySlider.value, 10); // Range: 0 to 100
            if (clarityValue !== 50) { // Default is 50 (no change)
                const contrast = clarityValue / 50; // Normalize to 0-2
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = ((data[i] - 128) * contrast) + 128;
                    data[i + 1] = ((data[i + 1] - 128) * contrast) + 128;
                    data[i + 2] = ((data[i + 2] - 128) * contrast) + 128;
                }
            }

            // Apply Highlight (Implemented as additional Brightness)
            const highlightValue = parseInt(highlightSlider.value, 10); // Range: 0 to 100
            if (highlightValue !== 0) {
                const factor = highlightValue * 0.5; // Scale down the factor
                for (let i = 0; i < data.length; i += 4) {
                    // Only brighten pixels that are not too dark
                    if (data[i] > 50 || data[i + 1] > 50 || data[i + 2] > 50) {
                        data[i] += factor;
                        data[i + 1] += factor;
                        data[i + 2] += factor;
                    }
                }
            }

            // Put modified data back
            ppCtx.putImageData(imageData, 0, 0);

            // Apply Sharpening
            const sharpeningValue = parseInt(sharpeningSlider.value, 10); // Range: 0 to 100
            if (sharpeningValue > 0) {
                applySharpeningFilter(ppCtx, sharpeningValue / 100); // Normalize to 0-1
            }

            // Update imageDataURL to use the postprocessed image
            imageDataURL = postprocessingCanvas.toDataURL();

            // Redraw overlayCanvas
            redrawCanvas();
        }

        // Function to Apply Sharpening Filter
        function applySharpeningFilter(ctx, intensity) {
            const imageData = ctx.getImageData(0, 0, postprocessingCanvas.width, postprocessingCanvas.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Simple sharpening kernel
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];

            const side = Math.round(Math.sqrt(kernel.length));
            const halfSide = Math.floor(side / 2);

            const src = data;
            const sw = width;
            const sh = height;
            const w = sw;
            const h = sh;
            const output = new Uint8ClampedArray(src.length);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let ky = 0; ky < side; ky++) {
                        for (let kx = 0; kx < side; kx++) {
                            const posY = y + ky - halfSide;
                            const posX = x + kx - halfSide;
                            if (posY >= 0 && posY < sh && posX >= 0 && posX < sw) {
                                const pos = posY * sw + posX;
                                const offset = pos * 4;
                                const weight = kernel[ky * side + kx];
                                r += src[offset] * weight;
                                g += src[offset + 1] * weight;
                                b += src[offset + 2] * weight;
                            }
                        }
                    }
                    const dstOffset = (y * w + x) * 4;
                    output[dstOffset] = Math.min(Math.max(r * intensity, 0), 255);
                    output[dstOffset + 1] = Math.min(Math.max(g * intensity, 0), 255);
                    output[dstOffset + 2] = Math.min(Math.max(b * intensity, 0), 255);
                    output[dstOffset + 3] = src[dstOffset + 3];
                }
            }

            // Put the sharpened data back
            for (let i = 0; i < data.length; i++) {
                data[i] = output[i];
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // Event Listeners for Postprocessing Controls
        grayscaleCheckbox.addEventListener('change', applyPostprocessing);
        highlightSlider.addEventListener('input', applyPostprocessing);
        claritySlider.addEventListener('input', applyPostprocessing);
        brightnessSlider.addEventListener('input', applyPostprocessing);
        sharpeningSlider.addEventListener('input', applyPostprocessing);

        /* -------------------- End of Postprocessing Functions -------------------- */

        // Handle Clicks on Highlighted Blocks
        // Already implemented via overlayCanvas click event

        // Function to Assign Text to Fields
        // Already handled via assignGroupToField

        // Function to Prevent Scrolling When Touching the Canvas in Draw or Crop Mode
        // Already implemented above

        // Function to Process OCR Data and Group Words within Rectangles
        // Already implemented via wordGroups

        /* -------------------- Crop Functionality -------------------- */
        // Already integrated above

        /* -------------------- End of Crop Functionality -------------------- */
    </script>
</body>
</html>
